//// Structures that represent intermediate state between UGC and
//// GroupDef/MissionDef/etc.  UGC Generate generates these structs.
////
//// NOTE: This is currently in an intermediate state.  It would
//// benefit from deleting all the unused options.
#pragma once

#include "wlGenesisMissionsGameStructs.h"
#include "wlGroupPropertyStructs.h"

typedef struct ExclusionObject ExclusionObject;
typedef struct HeightMapExcludeGrid HeightMapExcludeGrid;
typedef struct MissionWaypoint MissionWaypoint;
typedef struct TrackerHandle TrackerHandle;
typedef struct UGCCheckedAttrib UGCCheckedAttrib;
typedef struct UGCGenesisBackdrop UGCGenesisBackdrop;
typedef struct UGCGenesisInteriorReplace UGCGenesisInteriorReplace;
typedef struct UGCGenesisMissionChallenge UGCGenesisMissionChallenge;
typedef struct UGCGenesisMissionChallengeRequirements UGCGenesisMissionChallengeRequirements;
typedef struct UGCGenesisMissionContactRequirements UGCGenesisMissionContactRequirements;
typedef struct UGCGenesisMissionDescription UGCGenesisMissionDescription;
typedef struct UGCGenesisMissionExtraVolume UGCGenesisMissionExtraVolume;
typedef struct UGCGenesisMissionObjective UGCGenesisMissionObjective;
typedef struct UGCGenesisMissionRoomRequirements UGCGenesisMissionRoomRequirements;
typedef struct UGCGenesisMissionZoneChallenge UGCGenesisMissionZoneChallenge;
typedef struct UGCGenesisPrefab UGCGenesisPrefab;
typedef struct UGCGenesisProceduralEncounterProperties UGCGenesisProceduralEncounterProperties;
typedef struct UGCGenesisRoomConstraint UGCGenesisRoomConstraint;
typedef struct UGCGenesisSolSysZoneMap UGCGenesisSolSysZoneMap;
typedef struct UGCGenesisSpace UGCGenesisSpace;
typedef struct UGCGenesisToPlaceObject UGCGenesisToPlaceObject;
typedef struct UGCGenesisWhenExternalChallenge UGCGenesisWhenExternalChallenge;
typedef struct UGCGenesisWhenExternalPrompt UGCGenesisWhenExternalPrompt;
typedef struct UGCGenesisWhenExternalRoom UGCGenesisWhenExternalRoom;
typedef struct UGCGenesisZoneExterior UGCGenesisZoneExterior;
typedef struct UGCGenesisZoneInterior UGCGenesisZoneInterior;
typedef struct UGCGenesisZoneMission UGCGenesisZoneMission;
typedef struct UGCGenesisZoneNodeLayout UGCGenesisZoneNodeLayout;
typedef struct UGCGenesisZoneShared UGCGenesisZoneShared;
typedef struct UGCRuntimeErrorContext UGCRuntimeErrorContext;
typedef struct ZoneMapEncounterRoomInfo ZoneMapEncounterRoomInfo;

AUTO_ENUM;
typedef enum UGCGenesisPathNodesFrom
{
	UGCGenesisPathNodesFrom_None,
	UGCGenesisPathNodesFrom_ChallengePos,
	UGCGenesisPathNodesFrom_GroupDef,
} UGCGenesisPathNodesFrom;
extern StaticDefineInt UGCGenesisPathNodesFromEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionWaypointMode
{
	UGCGenesisMissionWaypointMode_None,
	UGCGenesisMissionWaypointMode_AutogeneratedVolume,
	// UGCGenesisMissionWaypointMode_ChallengeVolume
	UGCGenesisMissionWaypointMode_Points,
} UGCGenesisMissionWaypointMode;
extern StaticDefineInt UGCGenesisMissionWaypointModeEnum[];

AUTO_STRUCT;
typedef struct UGCGenesisPlacementActorParams {
	WorldVariableDef **world_vars;
	WorldActorCostumeProperties *costume;
	const char *pcFSMName;
	const char *pcActorName;
	const char *pcActorCritterGroupName;
} UGCGenesisPlacementActorParams;
extern ParseTable parse_UGCGenesisPlacementActorParams[];
#define TYPE_parse_UGCGenesisPlacementActorParams UGCGenesisPlacementActorParams

AUTO_STRUCT;
typedef struct UGCGenesisPlacementChildParams
{
	char* pcLogicalName;
	Vec3 vOffset;
	Vec3 vPyr;

	UGCGenesisPlacementActorParams actor_params;

	U32 is_actor : 1;

	// See UGCGenesisPlacementParams for information on these booleans:
	bool bAbsolutePos;						AST(NAME("AbsolutePosition"))
	bool bSnapRayCast;						AST(NAME("SnapRayCast"))
	bool bSnapToGeo;						AST(NAME("SnapToGeo"))
	bool bSnapNormal;						AST(NAME("SnapNormal"))
	bool bLegacyHeightCheck;				AST(NAME("LegacyHeightCheck"))
} UGCGenesisPlacementChildParams;
extern ParseTable parse_UGCGenesisPlacementChildParams[];
#define TYPE_parse_UGCGenesisPlacementChildParams UGCGenesisPlacementChildParams

AUTO_STRUCT;
typedef struct UGCGenesisPlacementParams
{
	Vec3 position;							AST(NAME("Position"))
	Vec3 rotation;							AST(NAME("Rotation"))
	bool bAbsolutePos;						AST(NAME("AbsolutePosition"))	// Use the InternalSpawnPoint Y for height. Overrides SnapRayCast
	bool bSnapRayCast;						AST(NAME("SnapRayCast"))		// Do a ray cast to determine Y placement. Ignored if bAbsolutePos
	bool bSnapToGeo;						AST(NAME("SnapToGeo"))
	bool bSnapNormal;						AST(NAME("SnapNormal"))
	bool bLegacyHeightCheck;				AST(NAME("LegacyHeightCheck"))	// If SnapRayCast, use the old height check values to preserve legacy project functionality
	UGCGenesisPlacementChildParams **children; AST(NAME("ChildPlacement"))	// If this object has children (e.g. patrol, encounter, use these)
} UGCGenesisPlacementParams;

AUTO_STRUCT;//sfenton TODO: PropLoad: need to do fixup on this too
typedef struct UGCGenesisProceduralObjectParams
{
	char *model_name;										AST( NAME(ModelName) )
	WorldRoomProperties *room_properties;					AST( NAME(RoomProperties) )
	WorldPowerVolumeProperties *power_volume;				AST( NAME(PowerVolume) )
	WorldFXVolumeProperties *fx_volume;						AST( NAME(FXVolume) )
	WorldSkyVolumeProperties *sky_volume_properties;		AST( NAME(SkyVolume) )
	WorldSoundVolumeProperties *sound_volume_properties;	AST( NAME(SoundVolume) )
	WorldSoundSphereProperties *sound_sphere_properties;	AST( NAME(SoundSphere) )
	WorldActionVolumeProperties *action_volume_properties;	AST( NAME(ActionVolume) )
	WorldEventVolumeProperties *event_volume_properties;	AST( NAME(EventVolume) )
	WorldOptionalActionVolumeProperties *optionalaction_volume_properties; AST( NAME(OptionalActionVolume) )
	WorldCurve *curve;										AST( NAME(Curve) )
	WorldPatrolProperties *patrol_properties;				AST( NAME(PatrolProperties) )
	WorldInteractionProperties *interaction_properties;		AST( NAME(InteractionProperties) )
	WorldSpawnProperties *spawn_properties;					AST( NAME(SpawnProperties) )
	WorldPhysicalProperties physical_properties;			AST( NAME(PhysicalProperties) )
	WorldGenesisProperties *genesis_properties;				AST( NAME(Genesis) )
	WorldTerrainProperties terrain_properties;				AST( NAME(TerrainProperties) )
	GroupVolumeProperties *volume_properties;				AST( NAME(VolumeProperties) )
	GroupHullProperties *hull_properties;					AST( NAME(HullProperties) )
	WorldLightProperties *light_properties;					AST( NAME(LightProperties) )
} UGCGenesisProceduralObjectParams;
extern ParseTable parse_UGCGenesisProceduralObjectParams[];
#define TYPE_parse_UGCGenesisProceduralObjectParams UGCGenesisProceduralObjectParams

AUTO_STRUCT;
typedef struct UGCGenesisInstancedChildParams
{
	char* pcLogicalName;
	DisplayMessage displayNameMsg;							AST(STRUCT(parse_DisplayMessage))
	Vec3 vPyr;
	Vec3 vOffset;

	WorldActorCostumeProperties *pCostumeProperties;
	DisplayMessage critterGroupDisplayNameMsg;				AST(STRUCT(parse_DisplayMessage))
} UGCGenesisInstancedChildParams;
extern ParseTable parse_UGCGenesisInstancedChildParams[];
#define TYPE_parse_UGCGenesisInstancedChildParams UGCGenesisInstancedChildParams

AUTO_STRUCT;
typedef struct UGCGenesisContactParams
{
	char *pcContactName;									AST(NAME("ContactName"))
	REF_TO(PlayerCostume) hCostume;							AST(NAME("Costume"))
} UGCGenesisContactParams;
extern ParseTable parse_UGCGenesisContactParams[];
#define TYPE_parse_UGCGenesisContactParams UGCGenesisContactParams

AUTO_STRUCT;
typedef struct UGCGenesisInteractObjectParams
{
	bool bDisallowVolume;									AST(NAME(DisallowVolume))
	bool bIsUGCDoor;										AST(NAME(IsUGCDoor))

	bool clickieVisibleWhenCondPerEnt;						AST( NAME(ClickieVisibleWhenPerEnt) )
	Expression *clickieVisibleWhenCond;						AST( NAME(ClickieVisibleWhen) LATEBIND )

	DisplayMessage displayNameMsg;							AST( NAME(DisplayName) STRUCT(parse_DisplayMessage) )
	Expression *succeedWhenCond;							AST( NAME(SucceedWhen) LATEBIND )	
	Expression *interactWhenCond;							AST( NAME(InteractWhen) LATEBIND )
	WorldInteractionPropertyEntry **eaInteractionEntries;	AST( NAME(InteractionEntry) )
} UGCGenesisInteractObjectParams;
extern ParseTable parse_UGCGenesisInteractObjectParams[];
#define TYPE_parse_UGCGenesisInteractObjectParams UGCGenesisInteractObjectParams

AUTO_STRUCT;
typedef struct UGCGenesisInstancedObjectParams
{
	F32 model_scale[3];										AST( NAME(ModelScale) )
	Expression *encounterSpawnCond;							AST( NAME(EncounterSpawnWhen) LATEBIND )
	Expression *encounterDespawnCond;						AST( NAME(EncounterDespawnWhen) LATEBIND )
	bool has_patrol;										AST( NAME(HasPatrol) )
	const char* pcFSMName;									AST( NAME(FSMName) )
	UGCGenesisInstancedChildParams **eaChildParams;			AST( NAME(ChildParam) NAME(ActorData) )
	bool bChildParamsAreGroupDefs;							AST( NAME(ChildParamsAreGroupDefs))
	char *pcMissionName;									AST( NAME(MissionName))
	UGCGenesisMissionContactRequirements *pContact;			AST(NAME("Contact"))
} UGCGenesisInstancedObjectParams;
extern ParseTable parse_UGCGenesisInstancedObjectParams[];
#define TYPE_parse_UGCGenesisInstancedObjectParams UGCGenesisInstancedObjectParams

AUTO_STRUCT;
typedef struct UGCGenesisObjectVolume
{
	// Determines if we use the size for a cube or a sphere
	bool is_square;											AST(NAME("IsSquare"))
	// if this is true, size is a relative scale of the object's radius or bounds
	bool is_relative;										AST(NAME("IsRelative"))
	// Take the object bounds and scale them by the following
	F32 size;												AST(NAME("Size"))
	// Or, ignore all the previous and just use these volume properties
	GroupVolumeProperties *pVolumeProperties;				AST(NAME("VolumeProperties"))
} UGCGenesisObjectVolume;
extern ParseTable parse_UGCGenesisObjectVolume[];
#define TYPE_parse_UGCGenesisObjectVolume UGCGenesisObjectVolume

AUTO_STRUCT;
typedef struct UGCGenesisGroupDefChildParam
{
	int iValue;
	const char *astrValue;		AST(POOL_STRING)
	const char *astrParameter;	AST(POOL_STRING)
} UGCGenesisGroupDefChildParam;
extern ParseTable parse_UGCGenesisGroupDefChildParam[];
#define TYPE_parse_UGCGenesisGroupDefChildParam UGCGenesisGroupDefChildParam

AUTO_STRUCT;
typedef struct UGCGenesisRoomDoorSwitch
{
	int iIndex;
	int iSelected;
	const char *astrScopePath;									AST(POOL_STRING)
} UGCGenesisRoomDoorSwitch;
extern ParseTable parse_UGCGenesisRoomDoorSwitch[];
#define TYPE_parse_UGCGenesisRoomDoorSwitch UGCGenesisRoomDoorSwitch

// An important object that must be placed inside our room
AUTO_STRUCT;
typedef struct UGCGenesisObject
{
	// exactly one of these should be filled out
	GroupDefRef obj;										AST(EMBEDDED_FLAT)
	REF_TO(DoorTransitionSequenceDef) start_spawn_using_transition; AST(NAME("StartSpawnUsingTransition"))

	GenesisChallengeType challenge_type;					AST(NAME("ChallengeType"))
	char *challenge_name;									AST(NAME("ExternalName"))
	int challenge_id;										AST(NAME("ChallengeID"))
	UGCGenesisPlacementParams params;						AST(EMBEDDED_FLAT)
	bool has_patrol;
	WorldPatrolProperties *patrol_specified;				AST(NAME("SpecifiedPatrol"))
	bool challenge_is_unique;								AST(NAME("ChallengeIsUnique"))
	bool force_named_object;								AST(NAME("ForceNamedObject"))
	char *spawn_point_name;									AST(NAME("ChallengeSpawnName"))
	bool is_trap;											AST(NAME("IsTrap"))
	int platform_group;										AST(NAME("PlatformGroup"))
	int platform_parent_group;								AST(NAME("PlatformParentGroup"))
	int platform_parent_level;								AST(NAME("PlatformParentLevel"))
	UGCGenesisGroupDefChildParam **eaChildParams;			AST(NAME("ChildParam"))
	UGCGenesisRoomDoorSwitch **eaRoomDoors;					AST(NAME("RoomDoor"))

	UGCGenesisObjectVolume *volume;							AST(NAME("Volume"))

	// If set, where golden path nodes for this challenge come from.
	UGCGenesisPathNodesFrom ePathNodesFrom;			AST(NAME("PathNodesFrom"))

	// A list of other challenges to connect to.
	char** eastrPathNodesAutoconnectChallenge;		AST(NAME("PathNodesAutoconnectChallenge"))

	// If set, all the nodes in this challenge autoconnect to the closest other node.
	bool bPathNodesAutoconnectNearest;				AST(NAME("PathNodesAutoConnectNearest"))

	const char *astrObjectSoundEvent;				AST(NAME("ObjectSoundEvent") POOL_STRING)

	UGCRuntimeErrorContext* source_context;			AST(NAME("SourceContext"))
} UGCGenesisObject;
extern ParseTable parse_UGCGenesisObject[];
#define TYPE_parse_UGCGenesisObject UGCGenesisObject

// A patrol object that will get placed
AUTO_STRUCT;
typedef struct UGCGenesisPatrolObject
{
	UGCGenesisObject* owner_challenge;						AST(NAME("OwnerChallenge"))
	GenesisPatrolType type;									AST(NAME("Type"))

	// Path-specific data
	bool path_start_is_challenge_pos;						AST(NAME("PathStartIsChallengePos"))
	UGCGenesisPlacementParams path_start;					AST(NAME("PathStart"))
	UGCGenesisPlacementParams path_end;						AST(NAME("PathEnd"))
} UGCGenesisPatrolObject;
extern ParseTable parse_UGCGenesisPatrolObject[];
#define TYPE_parse_UGCGenesisPatrolObject UGCGenesisPatrolObject

////////////////////////////////////////////////////////////
// Placement data structures
//
// These all are created during genesisGenerate()
////////////////////////////////////////////////////////////
AUTO_STRUCT;
typedef struct UGCGenesisToPlaceObject
{
	const char *object_name;				AST( POOL_STRING )
	Mat4 mat;
	bool mat_relative;
	int uid;								// If zero, generate a new GroupDef based on the UGCGenesisProceduralObjectParams below
	U32 seed;
	F32 scale;
	bool challenge_is_unique;				// If TRUE, use challenge_name as logical name, else logical group
	GenesisChallengeType challenge_type;
	char *challenge_name;					// Used as the logical group or logical name
	U32 challenge_index;					// Unique index in challenge group
	bool force_named_object;				// This object *always* gets a logical name, even if we have to place a group above it
	UGCGenesisToPlaceObject *parent;		AST( UNOWNED )
	UGCGenesisProceduralObjectParams *params;		// Only used if uid==0
	UGCGenesisInteractObjectParams *interact;		// In UGCGenesis, object must also be instanced. This restriction doesn't exist in UGC.
	UGCGenesisInstancedObjectParams *instanced;	// Only used if uid!=0 (Never needs to be freed; points directly to MissionReqs)
	const char *spawn_name;					AST( POOL_STRING ) // Logical name at map scope for a subobject called "SpawnPoint"
	const char *trap_name;					AST( POOL_STRING ) // Logical name at map scope for a subobject called "Trap_Core"

	UGCGenesisGroupDefChildParam **eaChildParams;
	UGCGenesisRoomDoorSwitch **eaRoomDoors;

	GroupDef *group_def;					AST( UNOWNED ) // If we're manually creating GroupDefs
	U32 uid_in_parent;						// Filled in while creating objects
	UGCRuntimeErrorContext* source_context;
} UGCGenesisToPlaceObject;
extern ParseTable parse_UGCGenesisToPlaceObject[];
#define TYPE_parse_UGCGenesisToPlaceObject UGCGenesisToPlaceObject

AUTO_STRUCT;
typedef struct UGCGenesisToPlacePatrol
{
	char* patrol_name;
	WorldPatrolProperties patrol_properties;

	UGCRuntimeErrorContext* source_context;
} UGCGenesisToPlacePatrol;
extern ParseTable parse_UGCGenesisToPlacePatrol[];
#define TYPE_parse_UGCGenesisToPlacePatrol UGCGenesisToPlacePatrol

AUTO_STRUCT AST_FIXUPFUNC( fixupUGCGenesisToPlacePlatformGroup );
typedef struct UGCGenesisToPlacePlatformGroup
{
	int group_id;
	int platform_level;
	HeightMapExcludeGrid *platform_grid;		NO_AST
} UGCGenesisToPlacePlatformGroup;
extern ParseTable parse_UGCGenesisToPlacePlatformGroup[];
#define TYPE_parse_UGCGenesisToPlacePlatformGroup UGCGenesisToPlacePlatformGroup

AUTO_STRUCT;
typedef struct UGCGenesisToPlaceState
{
	UGCGenesisToPlaceObject** objects;
	
	// Patrols need to be placed later so that different room's patrols
	// can be linked together
	UGCGenesisToPlacePatrol** patrols;

	UGCGenesisToPlacePlatformGroup** platform_groups;
} UGCGenesisToPlaceState;
extern ParseTable parse_UGCGenesisToPlaceState[];
#define TYPE_parse_UGCGenesisToPlaceState UGCGenesisToPlaceState

AUTO_STRUCT;
typedef struct UGCGenesisMapDescription
{
	bool is_tracking_enabled;										AST(NAME("TrackingEnabled"))

	//UGC
	UGCGenesisSpace *space_ugc;										AST(NAME("SpaceUGC"))
	UGCGenesisPrefab *prefab_ugc;									AST(NAME("PrefabUGC"))

	//Mission Data
	UGCGenesisMissionDescription **missions;						AST(NAME("MissionDescription"))
	UGCGenesisMissionChallenge **shared_challenges;					AST(NAME("SharedChallenge"))
} UGCGenesisMapDescription;
extern ParseTable parse_UGCGenesisMapDescription[];
#define TYPE_parse_UGCGenesisMapDescription UGCGenesisMapDescription

AUTO_STRUCT;
typedef struct UGCGenesisZoneMapData
{
	U32 seed;														AST(NAME("Seed"))
	U32 detail_seed;												AST(NAME("DetailSeed"))
	bool is_map_tracking_enabled;									AST(NAME("MapTrackingEnabled"))

	//Layout Data
	UGCGenesisSolSysZoneMap **solar_systems;						AST(NAME("SolarSystem"))
	UGCGenesisZoneShared **genesis_shared;							AST(NAME("UGCShared"))
	UGCGenesisZoneInterior **genesis_interiors;						AST(NAME("GenesisInterior"))
	UGCGenesisZoneExterior *genesis_exterior;						AST(NAME("GenesisExterior"))
	UGCGenesisZoneNodeLayout *genesis_exterior_nodes;				AST(NAME("GenesisExteriorNodes"))

	//Mission Data
	UGCGenesisZoneMission **genesis_mission;						AST(NAME("GenesisMission"))
	UGCGenesisMissionZoneChallenge **genesis_shared_challenges;		AST(NAME("GenesisSharedChallenge"))
	UGCGenesisProceduralEncounterProperties **encounter_overrides;	AST(NAME("EncounterOverride"))

	// Kept for reference and possible revision
	UGCGenesisMapDescription *map_desc;								AST(NAME("MapDescription"))
} UGCGenesisZoneMapData;
extern ParseTable parse_UGCGenesisZoneMapData[];
#define TYPE_parse_UGCGenesisZoneMapData UGCGenesisZoneMapData

// --------------------------------------------------------------------------
// Map Description Mission Data
// --------------------------------------------------------------------------

AUTO_ENUM;
typedef enum UGCGenesisMissionExitFrom
{
	UGCGenesisMissionExitFrom_Entrance,
	UGCGenesisMissionExitFrom_DoorInRoom,
	UGCGenesisMissionExitFrom_Anywhere,
	UGCGenesisMissionExitFrom_Challenge,
} UGCGenesisMissionExitFrom;
extern StaticDefineInt UGCGenesisMissionExitFromEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionGenerationType
{
	UGCGenesisMissionGenerationType_PlayerMission,
	UGCGenesisMissionGenerationType_OpenMission,
	UGCGenesisMissionGenerationType_OpenMission_NoPlayerMission,
} UGCGenesisMissionGenerationType;
extern StaticDefineInt UGCGenesisMissionGenerationTypeEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionGrantType 
{
	UGCGenesisMissionGrantType_MapEntry,
	UGCGenesisMissionGrantType_RandomNPC,
	UGCGenesisMissionGrantType_Contact,
	UGCGenesisMissionGrantType_Manual,
} UGCGenesisMissionGrantType;
extern StaticDefineInt UGCGenesisMissionGrantTypeEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionTurnInType 
{
	UGCGenesisMissionTurnInType_Automatic,
	UGCGenesisMissionTurnInType_GrantingContact,
	UGCGenesisMissionTurnInType_DifferentContact,
} UGCGenesisMissionTurnInType;
extern StaticDefineInt UGCGenesisMissionTurnInTypeEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionFailType
{
	UGCGenesisMissionFailType_Never,
	UGCGenesisMissionFailType_Timeout,
} UGCGenesisMissionFailType;
extern StaticDefineInt UGCGenesisMissionFailTypeEnum[];

AUTO_ENUM;
typedef enum UGCGenesisWhenType
{
	// When conditions that shouldn't be used in missions.
	UGCGenesisWhen_MapStart,				// From the start
	UGCGenesisWhen_Manual,					// Not allowed by default, other places may override
	UGCGenesisWhen_MissionComplete,			// Not allowed until the primary mission succeeds.
	UGCGenesisWhen_MissionNotInProgress,	// Triggers at MapEntry unless the mission has been started
	UGCGenesisWhen_ObjectiveComplete,		// Names are objectives, complete one to trigger
	UGCGenesisWhen_ObjectiveCompleteAll,	// Names are objectives, complete all to trigger
	UGCGenesisWhen_ObjectiveInProgress,		// Names are objectives, have any active to trigger
	UGCGenesisWhen_ChallengeAdvance,		// Names are challenges, complete one to trigger

	// When conditions that are always safe
	UGCGenesisWhen_PromptStart,				// Names are prompts, first one to start triggers
	UGCGenesisWhen_PromptComplete,			// Names are prompts, first one to complete triggers
	UGCGenesisWhen_PromptCompleteAll,		// Names are prompts, complete all to trigger
	UGCGenesisWhen_ContactComplete,			// Names are ContactDefs, first one to complete triggers
	UGCGenesisWhen_ChallengeComplete,		// Names are challenges, complete all to trigger
	UGCGenesisWhen_RoomEntry,				// Names are rooms, first one entered triggers
	UGCGenesisWhen_RoomEntryAll,			// Names are rooms, enter *all* to trigger
	UGCGenesisWhen_CritterKill,				// Names are CritterDefs and CritterGroups, kill a number of them to trigger
	UGCGenesisWhen_ItemCount,				// Names are ItemDefs, have a certain number of them in your inventory to succeed

	// When conditions added only for UGC
	UGCGenesisWhen_ExternalOpenMissionComplete,
	UGCGenesisWhen_ExternalChallengeComplete,
	UGCGenesisWhen_ExternalPromptComplete,
	UGCGenesisWhen_ExternalRoomEntry,
	UGCGenesisWhen_ExternalMapStart,
	UGCGenesisWhen_ExternalRewardBoxLooted,
	UGCGenesisWhen_RewardBoxLooted,
	UGCGenesisWhen_ReachChallenge,

	// When conditions that exist only for missions
	UGCGenesisWhen_AllOf,					// All child objectives get granted simultaneously, complete
											// all of them to trigger
	UGCGenesisWhen_InOrder,					// Child objectives get granted in order, complete all of
											// them to trigger
	UGCGenesisWhen_Branch,					// All child objectives get granted simultaneously, complete
											// one to trigger, and when one succeeds all the others
											// immediately fail
} UGCGenesisWhenType;
extern StaticDefineInt UGCGenesisWhenTypeEnum[];

AUTO_STRUCT;
typedef struct UGCGenesisWhenRoom
{
	char *roomName;									AST(STRUCTPARAM NAME("RoomName"))
	char *layoutName;								AST(STRUCTPARAM NAME("LayoutName"))
} UGCGenesisWhenRoom;
extern ParseTable parse_UGCGenesisWhenRoom[];
#define TYPE_parse_UGCGenesisWhenRoom UGCGenesisWhenRoom

AUTO_STRUCT;
typedef struct UGCGenesisWhenPromptBlock
{
	char* promptName;								AST(NAME("PromptName"))
	char* blockName;								AST(NAME("BlockName"))
} UGCGenesisWhenPromptBlock;
extern ParseTable parse_UGCGenesisWhenPromptBlock[];
#define TYPE_parse_UGCGenesisWhenPromptBlock UGCGenesisWhenPromptBlock

AUTO_STRUCT;
typedef struct UGCGenesisWhen
{
	UGCGenesisWhenType type;						AST(NAME("whenType", "ShowWhen", "SpawnWhen"))

	// NOTE: Stopgap solution.  The best solution would be to have a way to nest Whens. 
	bool bNot;										AST(NAME("Not"))
	UGCCheckedAttrib* checkedAttrib;				AST(NAME("CheckedAttrib"))

	char **eaChallengeNames;						AST(NAME("WhenChallengeName", "ShowWhenChallengeName", "SpawnWhenChallengeName"))
	int iChallengeNumToComplete;					AST(NAME("WhenChallengeNumToComplete", "ShowWhenChallengeNumToComplete"))

	UGCGenesisWhenRoom **eaRooms;					AST(NAME("WhenRoomName", "ShowWhenRoomName", "SpawnWhenRoomName"))								
	char **eaObjectiveNames;						AST(NAME("WhenObjectiveName", "ShowWhenObjectiveName", "SpawnWhenObjectiveName"))
	char **eaPromptNames;							AST(NAME("WhenPromptName", "ShowWhenPromptName", "SpawnWhenPromptName"))
	UGCGenesisWhenPromptBlock** eaPromptBlocks;		AST(NAME("WhenPromptBlock"))
	char *pcPromptChallengeName;					AST(NAME("WhenPromptChallengeName"))
	char *pcPromptMapName;							AST(NAME("WhenPromptMapName"))
	char **eaContactNames;							AST(NAME("WhenContactName"))
	
	char **eaCritterDefNames;						AST(NAME("WhenCritterDefName"))
	char **eaCritterGroupNames;						AST(NAME("WhenCritterGroupName"))
	int iCritterNumToComplete;						AST(NAME("WhenCritterNumToComplete"))
	const char **eaExternalMissionNames;			AST(NAME("WhenExternalMission") POOL_STRING)
	const char **eaExternalMapNames;				AST(NAME("WhenExternalMap"))
	const char* astrExternalAlternateMapForWaypoint;	AST(NAME("WhenExternalAlternateMapForWaypoint"))
	bool bAnyCrypticMap;							AST(NAME("WhenAnyCrypticMap"))
	UGCGenesisWhenExternalChallenge** eaExternalChallenges; AST(NAME("WhenExternalChallenge"))
	UGCGenesisWhenExternalRoom **eaExternalRooms; AST(NAME("WhenExternalRoom"))
	UGCGenesisWhenExternalPrompt **eaExternalPrompts;	AST(NAME("WhenExternalPrompt"))

	char **eaItemDefNames;							AST(NAME("WhenItemDefName"))
	int iItemCount;									AST(NAME("WhenItemCount"))
} UGCGenesisWhen;
extern ParseTable parse_UGCGenesisWhen[];
#define TYPE_parse_UGCGenesisWhen UGCGenesisWhen

AUTO_ENUM;
typedef enum UGCGenesisMissionCostumeType
{
	UGCGenesisMissionCostumeType_Specified,
	UGCGenesisMissionCostumeType_PetCostume,
	UGCGenesisMissionCostumeType_CritterGroup,
	UGCGenesisMissionCostumeType_Player,
} UGCGenesisMissionCostumeType;
extern StaticDefineInt UGCGenesisMissionCostumeTypeEnum[];

AUTO_STRUCT;
typedef struct UGCGenesisMissionCostume
{
	UGCGenesisMissionCostumeType eCostumeType;			AST(NAME("CostumeType", "UsePetCostume"))

	// CostumeType Specified
	REF_TO(PlayerCostume) hCostume;					AST(NAME("Costume"))

	// CostumeType PetCostume
	REF_TO(PetContactList) hPetCostume;				AST(NAME("PetCostume"))

	// CostumeType CritterGroup
	ContactMapVarOverrideType eCostumeCritterGroupType;	AST(NAME("CostumeCritterGroupType"))
	// exactly one of these will be specified
	REF_TO(CritterGroup) hCostumeCritterGroup;		AST(NAME("CostumeCritterGroup"))
	char* pchCostumeMapVar;							AST(NAME("CostumeMapVar"))
	char* pchCostumeIdentifier;						AST(NAME("CostumeIdentifier"))
} UGCGenesisMissionCostume;
extern ParseTable parse_UGCGenesisMissionCostume[];
#define TYPE_parse_UGCGenesisMissionCostume UGCGenesisMissionCostume

AUTO_STRUCT;
typedef struct UGCGenesisMissionGrant_Contact {
	char* pcOfferText;								AST(NAME("OfferText"))
	char* pcInProgressText;							AST(NAME("InProgressText"))
} UGCGenesisMissionGrant_Contact;
extern ParseTable parse_UGCGenesisMissionGrant_Contact[];
#define TYPE_parse_UGCGenesisMissionGrant_Contact UGCGenesisMissionGrant_Contact

AUTO_STRUCT;
typedef struct UGCGenesisMissionTurnIn_Contact {
	char* pcCompletedText;							AST(NAME("CompletedText"))
	char* pcMissionReturnText;						AST(NAME("MissionReturnText"))
} UGCGenesisMissionTurnIn_Contact;
extern ParseTable parse_UGCGenesisMissionTurnIn_Contact[];
#define TYPE_parse_UGCGenesisMissionTurnIn_Contact UGCGenesisMissionTurnIn_Contact

AUTO_STRUCT;
typedef struct UGCGenesisMissionGrantDescription
{
	UGCGenesisMissionGrantType eGrantType;			AST(NAME("GrantType"))
	UGCGenesisMissionGrant_Contact *pGrantContact;	AST(NAME("GrantContact"))

	UGCGenesisMissionTurnInType eTurnInType;		AST(NAME("TurnInType"))
	UGCGenesisMissionTurnIn_Contact *pTurnInContact; AST(NAME("TurnInContact"))

	UGCGenesisMissionFailType eFailType;			AST(NAME("FailType"))
	int iFailTimeoutSeconds;						AST(NAME("FailTimeoutSeconds"))

	bool bRepeatable;								AST(NAME("CanRepeat"))
	F32 fRepeatCooldownHours;						AST(NAME("RepeatCooldownHours"))
	F32 fRepeatCooldownHoursFromStart;				AST(NAME("RepeatCooldownHoursFromStart"))
	
	// Number of times that the mission can be run before it enter cooldown. Only values > 1 will
	// produce behavior different from that of pre-fRepeatCooldownTimes behavior. 
	// This is used for both repeat cooldown and cooldown from start
	U32 iRepeatCooldownCount;						AST( NAME("RepeatCooldownCount"))

	// Used with iRepeatCooldownCount
	// If true then mission cooldown start / complete times are set to the nearest block based on cooldown time
	// Example 24 in fRepeatCooldownHours would result in mission cooldwon times being started at 12:00am and ending 24 hours later
	// When it is past the last block then its in a new cooldown block (count starts over again).
	bool bRepeatCooldownBlockTime;					AST( NAME("RepeatCooldownBlockTime"))

	const char **eaRequiresMissions;				AST(NAME("RequiresMission"))
} UGCGenesisMissionGrantDescription;
extern ParseTable parse_UGCGenesisMissionGrantDescription[];
#define TYPE_parse_UGCGenesisMissionGrantDescription UGCGenesisMissionGrantDescription

AUTO_STRUCT;
typedef struct UGCGenesisMissionOpenMissionDescription
{
	char *pcPlayerSpecificDisplayName;				AST(NAME("DisplayName"))
	char *pcPlayerSpecificShortText;				AST(NAME("UIString", "ShortText"))
} UGCGenesisMissionOpenMissionDescription;
extern ParseTable parse_UGCGenesisMissionOpenMissionDescription[];
#define TYPE_parse_UGCGenesisMissionOpenMissionDescription UGCGenesisMissionOpenMissionDescription

AUTO_STRUCT;
typedef struct UGCGenesisMissionStartDescription
{
	char *pcStartLayout;							AST(NAME("StartLayout"))
	char *pcStartRoom;								AST(NAME("StartRoom"))
	bool bHasEntryDoor;								AST(NAME("HasEntryDoor"))
	F32 *eaStartPosOverride;						AST(NAME("StartPosOverride")) // Only used in fully specified layout mode
	REF_TO(DoorTransitionSequenceDef) hStartTransitionOverride; AST(NAME("StartTransitionOverride"))

	UGCGenesisMissionExitFrom eExitFrom;			AST(NAME("ExitFrom"))
	char *pcExitLayout;								AST(NAME("ExitLayout"))
	char *pcExitRoom;								AST(NAME("ExitRoom")) // This only applies if exit from is a room, or when exterior has a shape
	char **eaExitChallenges;							AST(NAME("ExitChallenge")) // This only applies if exit from is a challenge
	REF_TO(DoorTransitionSequenceDef) hExitTransitionOverride; AST(NAME("ExitTransitionOverride"))
	UGCGenesisMissionCostume exitPromptCostume;		AST(NAME("ExitPromptCostume2"))

	bool bContinue;									AST(NAME("Continue"))
	UGCGenesisMissionExitFrom eContinueFrom;		AST(NAME("ContinueFrom"))
	char *pcContinueLayout;							AST(NAME("ContinueLayout"))
	char *pcContinueRoom;							AST(NAME("ContinueRoom")) // This only applies if continue from is a room, or when exterior has a shape
	char *pcContinueChallenge;						AST(NAME("ContinueChallenge")) // This only applies if continue from is a challenge
	char *pcContinueMap;							AST(NAME("ContinueMap"))
	WorldVariable **eaContinueVariables;			AST(NAME("ContinueVariable"))
	REF_TO(DoorTransitionSequenceDef) hContinueTransitionOverride; AST(NAME("ContinueTransitionOverride"))
	
	UGCGenesisMissionCostume continuePromptCostume;	AST(NAME("ContinuePromptCostume2"))
	char *pcContinuePromptButtonText;				AST(NAME("ContinuePromptButtonText"))
	char *pcContinuePromptCategoryName;				AST(NAME("ContinuePromptCategoryName"))
	WorldOptionalActionPriority eContinuePromptPriority; AST(NAME("ContinuePromptPriority"))
	char *pcContinuePromptTitleText;				AST(NAME("ContinuePromptTitleText"))
	char **eaContinuePromptBodyText;				AST(NAME("ContinuePromptBodyText"))


	// These apply if the mission is to have an entrance from some
	// other map, but only when the mission is granted.
	char *pcEntryFromMapName;						AST(NAME("EntryFromMapName"))
	char *pcEntryFromInteractableName;				AST(NAME("EntryFromInteractableName"))
} UGCGenesisMissionStartDescription;
extern ParseTable parse_UGCGenesisMissionStartDescription[];
#define TYPE_parse_UGCGenesisMissionStartDescription UGCGenesisMissionStartDescription

AUTO_STRUCT;
typedef struct UGCGenesisMissionChallengeClickie
{
	// The interaction def used for the clickie
	REF_TO(InteractionDef) hInteractionDef;			AST(NAME("InteractionDef"))

	// The text shown above the clickie
	char *strVisibleName;							AST(NAME("VisibleName"))

	// The text shown to interacted with the clickie.
	char *pcInteractText;							AST(NAME("InteractText"))

	// The text shown if the clickie has been successfully interacted with
	char *pcSuccessText;							AST(NAME("SuccessText"))

	// The text shown if the clickie has failed to interact successfully
	char *pcFailureText;							AST(NAME("FailureText"))

	// The animation the player sees while interacting with the clickie
	REF_TO(AIAnimList) hInteractAnim;				AST(NAME("InteractAnim"))

	// The name of the reward table that is dropped when this clickie succeeds
	REF_TO(RewardTable) hRewardTable;				AST(NAME("RewardTable"))

	// Take the checked attrib item from the player's inventory
	bool bConsumeSuccessItem;						AST(NAME("ConsumeSuccessItem"))

	// Indicates we need special door logic
	bool bIsUGCDoor;								AST(NAME("IsUGCDoor"))
} UGCGenesisMissionChallengeClickie;
extern ParseTable parse_UGCGenesisMissionChallengeClickie[];
#define TYPE_parse_UGCGenesisMissionChallengeClickie UGCGenesisMissionChallengeClickie

AUTO_STRUCT;
typedef struct UGCGenesisMissionTrap
{
	bool bOnVolumeEntered;							AST(NAME("OnVolumeEntered"))
	char *pcPowerName;								AST(NAME("PowerName"))
	char *pcEmitterChallenge;						AST(NAME("EmitterChallenge"))
	char *pcTargetChallenge;						AST(NAME("TargetChallenge"))
} UGCGenesisMissionTrap;
extern ParseTable parse_UGCGenesisMissionTrap[];
#define TYPE_parse_UGCGenesisMissionTrap UGCGenesisMissionTrap

AUTO_STRUCT;
typedef struct UGCGenesisMissionChallenge 
{
	// The name of the challenge
	char *pcName;									AST(NAME("Name"))

	// Layout the challenge is in
	char *pcLayoutName;								AST(NAME("LayoutName"))

	// Which challenge to place.
	// The type acts as a filter if present.
	GenesisChallengeType eType;						AST(NAME("Type"))
	char *pcChallengeName;							AST(NAME("SpecificChallenge"))

	// How many copies of the challenge to place
	// If zero, then it means one.
	int iCount;										AST(NAME("Count"))

	// Logical name to give the internal spawnpoint in this challenge
	char *pcStartSpawnName;							AST(NAME("ChallengeSpawnName"))

	UGCGenesisWhen spawnWhen;						AST(NAME("SpawnWhen2"))

	// When true, this clickie is visible.  Note that if a clickie is
	// not visible, then it will not be able to be interacted with.
	UGCGenesisWhen clickieVisibleWhen;				AST(NAME("ClickieVisibleWhen"))

	// If set, successfully completing this challenge requires a having a checked attribute
	UGCCheckedAttrib* succeedCheckedAttrib;			AST(NAME("SucceedCheckedAttrib"))

	// Properties that are only valid for encounters/clickies.  Cannot
	// contain DisplayMessages.
	UGCGenesisMissionChallengeClickie* pClickie;	AST(NAME("Clickie"))
	UGCGenesisContactParams *pContact;				AST(NAME("Contact"))

	// Always make sure this challenge gets a name, so it can be referenced externally
	bool bForceNamedObject;							AST(NAME("ForceNamedObject"))

	Vec3 vPosition;									AST(NAME("Position"))
	Vec3 vRotation;									AST(NAME("Rotation"))
	bool bAbsolutePos;								AST(NAME("AbsolutePosition"))
	bool bSnapRayCast;								AST(NAME("SnapRayCast"))
	bool bSnapToGeo;								AST(NAME("SnapToGeo"))
	bool bSnapNormal;								AST(NAME("SnapNormal"))
	bool bLegacyHeightCheck;						AST(NAME("LegacyHeightCheck"))

	// If set, where golden path nodes for this challenge come from.
	UGCGenesisPathNodesFrom ePathNodesFrom;			AST(NAME("PathNodesFrom"))

	// A list of other challenges to connect to.
	char** eastrPathNodesAutoconnectChallenge;		AST(NAME("PathNodesAutoconnectChallenge"))

	// If set, all the nodes in this challenge autoconnect to the closest other node.
	bool bPathNodesAutoconnectNearest;				AST(NAME("PathNodesAutoConnectNearest"))

	WorldPatrolProperties *pPatrol;					AST(NAME("Patrol"))

	// For challenge types with child objects to be specifically overridden
	UGCGenesisPlacementChildParams **eaChildren;	AST(NAME("Child"))

	// If true, then eaChildren specifically applies to the direct
	// GroupDef children.  Otherwise it finds an applies to the first
	// found Encounter that is in this GroupDef.
	bool bChildrenAreGroupDefs;						AST(NAME("ChildrenAreGroupDefs"))

	// Currently only used for planets/space objects
	UGCGenesisObjectVolume *pVolume;				AST(NAME("Volume"))

	// Object platforms only apply to objects in the same platform group
	int iPlatformGroup;								AST(NAME("PlatformGroup")) // This object's group
	int iPlatformParentGroup;						AST(NAME("PlatformParentGroup")) // The parent group for this object
	int iPlatformParentLevel;						AST(NAME("PlatformParentLevel")) // The platform level in the parent object

	// Detail selectors
	UGCGenesisGroupDefChildParam **eaChildParams;	AST(NAME("ChildParam"))
	UGCGenesisRoomDoorSwitch **eaRoomDoors;			AST(NAME("RoomDoor"))

	// Traps
	UGCGenesisMissionTrap **eaTraps;				AST(NAME("Trap")) // Traps triggered by this object
	char *pcTrapObjective;							AST(NAME("TrapObjective")) // Objective that enables this trap

	// Sound
	const char *astrRoomToneSoundEvent;				AST(NAME("RoomToneSoundEvent") POOL_STRING)
	const char *astrRoomSoundDSP;					AST(NAME("RoomSoundDSP") POOL_STRING)
	const char *astrObjectSoundEvent;				AST(NAME("ObjectSoundEvent") POOL_STRING)

	// TODO: Possibly add Contact properties here that would
	//       be provided to the challenge.
} UGCGenesisMissionChallenge;
extern ParseTable parse_UGCGenesisMissionChallenge[];
#define TYPE_parse_UGCGenesisMissionChallenge UGCGenesisMissionChallenge

/// Transmogrified version of a challenge
AUTO_STRUCT;
typedef struct UGCGenesisMissionZoneChallenge
{
	char* pcName;									AST(NAME("Name"))
	GenesisChallengeType eType;						AST(NAME("Type"))
	int iNumToComplete;								AST(NAME("NumToComplete"))
	char *pcLayoutName;								AST(NAME("LayoutName"))

	UGCGenesisWhen spawnWhen;						AST(NAME("SpawnWhen2"))

	// When true, this clickie is visible.  Note that if a clickie is
	// not visible, then it will not be able to be interacted with.
	UGCGenesisWhen clickieVisibleWhen;				AST(NAME("ClickieVisibleWhen"))

	// If set, successfully completing this challenge requires having a checked attribute
	UGCCheckedAttrib* succeedCheckedAttrib;			AST(NAME("SucceedCheckedAttrib"))

    // Properties that are only valid for encounters/clickies
	// contain DisplayMessages.
	UGCGenesisMissionChallengeClickie* pClickie;	AST(NAME("Clickie"))
	UGCGenesisContactParams *pContact;				AST(NAME("Contact"))
	bool bForceNamedObject;							AST(NAME("ForceNamedObject"))
	UGCGenesisPlacementChildParams **eaChildren;	AST(NAME("Child"))
	bool bChildrenAreGroupDefs;						AST(NAME("ChildrenAreGroupDefs"))
	bool bIsVolume;									AST(NAME("IsVolume"))

	UGCGenesisMissionTrap **eaTraps;				AST(NAME("Trap"))
	char *pcTrapObjective;							AST(NAME("TrapObjective"))

	UGCRuntimeErrorContext* pSourceContext;			AST(NAME("SourceContext"))
} UGCGenesisMissionZoneChallenge;
extern ParseTable parse_UGCGenesisMissionZoneChallenge[];
#define TYPE_parse_UGCGenesisMissionZoneChallenge UGCGenesisMissionZoneChallenge

/// External version of a challenge, stored directly in a UGCGenesisWhen.
///
/// This is needed if the chalenge is on another map.
AUTO_STRUCT;
typedef struct UGCGenesisWhenExternalChallenge
{
	char* pcMapName;								AST(NAME("MapName"))
	char* pcName;									AST(NAME("Name"))
	GenesisChallengeType eType;						AST(NAME("Type"))

	UGCGenesisMissionChallengeClickie* pClickie;	AST(NAME("Clickie"))
	
	// If set, successfully completing this challenge requires a having a checked attribute
	UGCCheckedAttrib* succeedCheckedAttrib;			AST(NAME("SucceedCheckedAttrib"))
} UGCGenesisWhenExternalChallenge;
extern ParseTable parse_UGCGenesisWhenExternalChallenge[];
#define TYPE_parse_UGCGenesisWhenExternalChallenge UGCGenesisWhenExternalChallenge


/// External version of a "room", stored directly in a UGCGenesisWhen.
///
/// This is needed if the room is on another map.
AUTO_STRUCT;
typedef struct UGCGenesisWhenExternalRoom
{
	char* pcMapName;								AST(NAME("MapName"))
	char* pcName;									AST(NAME("Name"))
} UGCGenesisWhenExternalRoom;
extern ParseTable parse_UGCGenesisWhenExternalRoom[];
#define TYPE_parse_UGCGenesisWhenExternalRoom UGCGenesisWhenExternalRoom

/// External version of a "prompt", stored directly in a UGCGenesisWhen.
AUTO_STRUCT;
typedef struct UGCGenesisWhenExternalPrompt
{
	char* pcContactName;
	char* pcPromptName;

	// If you want a waypoint, you need to fill these out to place a waypoint marker
	char* pcEncounterName;
	char* pcEncounterMapName;
} UGCGenesisWhenExternalPrompt;
extern ParseTable parse_UGCGenesisWhenExternalPrompt[];
#define TYPE_parse_UGCGenesisWhenExternalPrompt UGCGenesisWhenExternalPrompt

typedef struct UGCGenesisMissionPrompt UGCGenesisMissionPrompt;

AUTO_STRUCT;
typedef struct UGCGenesisMissionPromptAction
{
	// Text for the prompt window button
	char *pcText;									AST(NAME("Text"))

	// Style for the button being generated
	const char* astrStyleName;						AST(NAME("Style") POOL_STRING)

	// MJF TODO: Remove legacy data when not used any more.  Superceded by multi-blocks in a prompt.
	// Optional next prompt to show
	char *pcNextPromptName;							AST(NAME("NextPromptName"))

    // Grant the mission
	bool bGrantMission;								AST(NAME("GrantMission"))

    // Do not fire off "PromptSuccess" events
	bool bDismissAction;							AST(NAME("DismissAction"))

	// Actions to perform when action it selected
	WorldGameActionBlock actionBlock;				AST(NAME("Actions"))

	// Optional next block to show, if set then this won't fire off prompt success events.
	char *pcNextBlockName;							AST(NAME("NextBlockName"))

	// When true, this action is available.
	UGCGenesisWhen when;							AST(NAME("When"))

	// If true then if you do not pass the skill check, a "disabled" version of the prompt should appear
	UGCCheckedAttrib* enabledCheckedAttrib;			AST(NAME("EnabledCheckedAttrib"))
} UGCGenesisMissionPromptAction;
extern ParseTable parse_UGCGenesisMissionPromptAction[];
#define TYPE_parse_UGCGenesisMissionPromptAction UGCGenesisMissionPromptAction

AUTO_STRUCT;
typedef struct UGCGenesisMissionPromptBlock
{
	// name for this block, only matters in named blocks
	char* name;										AST(NAME("BlockName"))

	// Costume for head shot
	UGCGenesisMissionCostume costume;				AST(NAME("Costume2"))

	// Costume style
	char* pchHeadshotStyle;							AST(NAME("HeadshotStyle"))
 
	// Cutscene for the prompt (used by NNO)
	REF_TO(CutsceneDef) hCutsceneDef;				AST(NAME("CutsceneDef"))

	// Animation for contact in cutscene (used by NNO)
	REF_TO(AIAnimList) hAnimList;					AST(NAME("AnimList"))

	// Text for the prompt window
	char *pcTitleText;								AST(NAME("TitleText"))
	char **eaBodyText;								AST(NAME("BodyText"))

	// Phrase to say
	char *pcPhrase;									AST(NAME("Phrase"))
	
	// Flags which specify specialized behavior for this special dialog block
	SpecialDialogFlags eDialogFlags;				AST(NAME("DialogFlags") FLAGS)

	// Options to show on the prompt window
	UGCGenesisMissionPromptAction **eaActions;		AST(NAME("Action"))
} UGCGenesisMissionPromptBlock;
extern ParseTable parse_UGCGenesisMissionPromptBlock[];
#define TYPE_parse_UGCGenesisMissionPromptBlock UGCGenesisMissionPromptBlock

AUTO_STRUCT;
typedef struct UGCGenesisMissionPrompt
{
	// Name of the Prompt
	char *pcName;									AST(NAME("Name"))

	// Layout the prompt is in
	char *pcLayoutName;								AST(NAME("LayoutName"))

	// If set, this prompt should apply to some map *other* the the
	// one being generated.  Then pcChallengeName is the logical name
	// of the contact.
	char **eaExternalMapNames;						AST(NAME("ExternalMapName"))

	// Challenge of the critter who will use this Contact (NULL means use an optional action)
	char *pcChallengeName;

	// If set, this prompt should apply to some contact *other* than
	// the one being generated.  pcExternalMapName and pcChallengeName
	// will be ignored then.
	const char* pcExternalContactName;				AST(POOL_STRING NAME("ExternalContactName"))

	// Defines when the prompt gets shown
	UGCGenesisWhen showWhen;						AST(NAME("ShowWhen"))

    // Optional action fields
	bool bOptional;									AST(NAME("OptionalPrompt"))
	char *pcOptionalButtonText;						AST(NAME("OptionalButtonText"))
	char *pcOptionalCategoryName;					AST(NAME("OptionalCategoryName"))
	WorldOptionalActionPriority eOptionalPriority;	AST(NAME("OptionalPriority"))
	bool bOptionalAutoExecute;						AST(NAME("OptionalAutoExecute"))
	bool bOptionalHideOnComplete;					AST(NAME("OptionalHideOnComplete"))

	// MJF TODO: Remove legacy data when not used any more.  Superceded by multi-blocks in a prompt.
	char *pcOptionalHideOnCompletePrompt;			AST(NAME("OptionalHideOnCompletePrompt"))

	// blocks
	UGCGenesisMissionPromptBlock sPrimaryBlock;		AST(EMBEDDED_FLAT)
	UGCGenesisMissionPromptBlock** namedBlocks;		AST(NAME("Block"))
} UGCGenesisMissionPrompt;
extern ParseTable parse_UGCGenesisMissionPrompt[];
#define TYPE_parse_UGCGenesisMissionPrompt UGCGenesisMissionPrompt

AUTO_STRUCT;
typedef struct UGCGenesisFSM
{
	const char *pcName;						AST(NAME("Name") POOL_STRING STRUCTPARAM KEY)
	const char *pcFileName;					AST(NAME("Filename") CURRENTFILE)
	char *pcChallengeLogicalName;			AST(NAME("ChallengeLogicalName"))

	UGCGenesisWhen activeWhen;

	WorldVariableDef **eaVarDefs;			AST(NAME("VarDef"))

	char *pcFSMName;						AST(NAME("FSMName"))
} UGCGenesisFSM;
extern ParseTable parse_UGCGenesisFSM[];
#define TYPE_parse_UGCGenesisFSM UGCGenesisFSM

AUTO_ENUM;
typedef enum UGCGenesisMissionPortalUseType
{
	UGCGenesisMissionPortal_Volume,
	UGCGenesisMissionPortal_Door,
} UGCGenesisMissionPortalUseType;
extern StaticDefineInt UGCGenesisMissionPortalUseTypeEnum[];

AUTO_ENUM;
typedef enum UGCGenesisMissionPortalType
{
	UGCGenesisMissionPortal_Normal,
	UGCGenesisMissionPortal_OneWayOutOfMap,
	UGCGenesisMissionPortal_BetweenLayouts,
} UGCGenesisMissionPortalType;
extern StaticDefineInt UGCGenesisMissionPortalTypeEnum[];

AUTO_STRUCT;
typedef struct UGCGenesisMissionPortal
{
	char *pcName;									AST(NAME("Name"))
	UGCGenesisMissionPortalType eType;				AST(NAME("Type"))
	UGCGenesisMissionPortalUseType eUseType;		AST(NAME("UseType"))

	// Layout the portal is in -- there will be an end layout name
	// only if the portal is the BetweenLayouts type.
	char *pcStartLayout;							AST(NAME("StartLayout", "LayoutName"))
	char *pcEndLayout;								AST(NAME("EndLayout"))

	// Rooms connected by the portal
	char *pcStartRoom;								AST(NAME("StartRoom"))
	char *pcEndRoom;								AST(NAME("EndRoom"))
	
	// Optional Door name to connect the portal
	char *pcStartDoor;								AST(NAME("StartDoor"))
	char *pcEndDoor;								AST(NAME("EndDoor"))

	// When this portal is active
	UGCGenesisWhen when;							AST(NAME("When"))

	// Spawn points (by logical name) to use, or NULL to create one
	char *pcStartSpawn;								AST(NAME("StartSpawn"))
	char *pcEndSpawn;								AST(NAME("EndSpawn"))

	// Challenge names of clickable object to use on each side, or NULL to create
	// a room volume.
	char *pcStartClickable;							AST(NAME("StartClickable"))
	char *pcEndClickable;							AST(NAME("EndClickable"))

	bool bStartUseVolume;							AST(NAME("StartUseVolume"))
	bool bEndUseVolume;								AST(NAME("EndUseVolume"))

	// The following data all is only relevant if the EndRoom is in
	// another map.
	char *pcEndZmap;								AST(NAME("EndZmap"))
	WorldVariableDef **eaEndVariables;				AST(NAME("EndVariable"))				
   
	// What text to display on the button that will warp you
	char *pcWarpToStartText;						AST(NAME("WarpToStartText"))
	char *pcWarpToEndText;							AST(NAME("WarpToEndText"))

	// TODO: As soon as we can do DoorInRoom on interiors, this should be added
	// UGCGenesisMissionPortalFrom eFrom;			AST(NAME("From"))
} UGCGenesisMissionPortal;
extern ParseTable parse_UGCGenesisMissionPortal[];
#define TYPE_parse_UGCGenesisMissionPortal UGCGenesisMissionPortal

AUTO_STRUCT;
typedef struct UGCGenesisMissionDrop {
	const char *astrMapName;				AST(NAME("MapName") POOL_STRING)

	const char *astrEncounterLogicalName;	AST(NAME("EncounterLogicalName") POOL_STRING)

	REF_TO(RewardTable) hReward;			AST(NAME("Reward"))
} UGCGenesisMissionDrop;
extern ParseTable parse_UGCGenesisMissionDrop[];
#define TYPE_parse_UGCGenesisMissionDrop UGCGenesisMissionDrop

AUTO_STRUCT;
typedef struct UGCGenesisMissionObjective {
	char *pcName;									AST(NAME("Name"))

	// This is the English text for the objective
	char *pcShortText;								AST(NAME("UIString", "ShortText"))

	// This is the English text for a floater that happens when the objective is complete
	char *pcSuccessFloaterText;						AST(NAME("SuccessFloaterText"))

    // A timeout, when this time elapses the objective auto-succeeds
	U32 uTimeout;									AST(NAME("TimeToComplete"))

    // These are for optional objectives
	bool bOptional;									AST(NAME("Optional"))

	// waypoint mode
	UGCGenesisMissionWaypointMode eWaypointMode;	AST(NAME("WaypointMode"))

	UGCGenesisWhen succeedWhen;						AST(NAME("SucceedWhen"))

	// On success reward. Added for UGC to be able to set this on the 'Get_Reward' submission
	REF_TO(RewardTable) hReward;					AST(NAME("Reward"))

	// This is used by the AllOf and InOrder types
	UGCGenesisMissionObjective **eaChildren;		AST(NAME("Objective"))

	// Extra on-start actions
	WorldGameActionProperties** eaOnStartActions;	AST(NAME("OnStartAction"))

	// Extra waypoints appear in addition to the auto-generated ones created by bShowWaypoints = true
	MissionWaypoint** eaExtraWaypoints;				AST(NAME("ExtraWaypoint") LATEBIND)
} UGCGenesisMissionObjective;
extern ParseTable parse_UGCGenesisMissionObjective[];
#define TYPE_parse_UGCGenesisMissionObjective UGCGenesisMissionObjective

/// Input data structure for the Generate step.
AUTO_STRUCT;
typedef struct UGCGenesisMissionZoneDescription
{
	// System name of the mission
	char *pcName;									AST(NAME("Name"))

	// English display name of the mission
	char *pcDisplayName;							AST(NAME("DisplayName"))

	// This is the English text for the objective
	char *pcShortText;								AST(NAME("UIString", "ShortText"))
	char *pcDescriptionText;						AST(NAME("DescriptionText"))
	char *pcSummaryText;							AST(NAME("Summary"))
	char *strReturnText;							AST(NAME("ReturnText"))

	// The category
	REF_TO(MissionCategory) hCategory;				AST(NAME("Category"))
	MissionPlayType ePlayType;						AST(NAME("PlayType"))
	ContentAuthorSource eAuthorSource;				AST(NAME("AuthorSource"))
	ContainerID ugcProjectID;						AST(NAME("UGCProjectID"))

	MissionLevelDef levelDef;						AST( EMBEDDED_FLAT )

	MissionShareableType eShareable;				AST(NAME("Shareable"))

    // The rewards
	REF_TO(RewardTable) hReward;					AST(NAME("Reward"))

	// Rewards
	F32 rewardScale;								AST(NAME("RewardScale"))

	// The description of how the mission is granted
	UGCGenesisMissionGrantDescription grantDescription; AST(NAME("Grant"))

	// The type of mission to generate
	UGCGenesisMissionGenerationType generationType;	AST(NAME("GenerationType", "IsOpenMission"))

    // The description of how this mission works as an Open Mission
	UGCGenesisMissionOpenMissionDescription *pOpenMissionDescription; AST(NAME("OpenMission"))

	// The description of where the player starts on the map
	UGCGenesisMissionStartDescription startDescription; AST(NAME("Start"))

	// A list of prompts
	UGCGenesisMissionPrompt **eaPrompts;				AST(NAME("Prompt"))

	// A list of FSMs
	UGCGenesisFSM **eaFSMs;

	// A list of portals
	UGCGenesisMissionPortal **eaPortals;				AST(NAME("Portal"))

	// A list of objectives to be completed in order
	UGCGenesisMissionObjective **eaObjectives;			AST(NAME("Objective"))

	// A list of mission drops
	UGCGenesisMissionDrop **eaMissionDrops;								AST(NAME("MissionDrops"))
} UGCGenesisMissionZoneDescription;
extern ParseTable parse_UGCGenesisMissionZoneDescription[];
#define TYPE_parse_UGCGenesisMissionZoneDescription UGCGenesisMissionZoneDescription

/// Input data structure for the Transmogrify step. 
AUTO_STRUCT;
typedef struct UGCGenesisMissionDescription
{
	UGCGenesisMissionZoneDescription zoneDesc;			AST(EMBEDDED_FLAT)
	
	// A list of challenges to be placed on the map
	UGCGenesisMissionChallenge **eaChallenges;			AST(NAME("Challenge"))
} UGCGenesisMissionDescription;
extern ParseTable parse_UGCGenesisMissionDescription[];
#define TYPE_parse_UGCGenesisMissionDescription UGCGenesisMissionDescription

/// Transmogrified version of a MissionDescription
AUTO_STRUCT;
typedef struct UGCGenesisZoneMission
{
	UGCGenesisMissionZoneDescription desc;				AST(EMBEDDED_FLAT)
	
	bool bTrackingEnabled;							AST(NAME("TrackingEnabled"))
	UGCGenesisMissionZoneChallenge** eaChallenges;		AST(NAME("Challenge"))
} UGCGenesisZoneMission;
extern ParseTable parse_UGCGenesisZoneMission[];
#define TYPE_parse_UGCGenesisZoneMission UGCGenesisZoneMission

/// A list of actions that can happen.
AUTO_STRUCT;
typedef struct UGCGenesisMissionAction
{
	char* promptName;								AST(NAME("PromptName"))
} UGCGenesisMissionAction;
extern ParseTable parse_UGCGenesisMissionAction[];
#define TYPE_parse_UGCGenesisMissionAction UGCGenesisMissionAction

/// A concrete list of extra requirements a mission can impose.
AUTO_STRUCT;
typedef struct UGCGenesisMissionRequirements
{
	// This exists so that the messages in this requirements structure
	// can be saved out.
	const char* messageFilename;					AST(CURRENTFILE)
	
	char* missionName;								AST(NAME("Name"))
	UGCGenesisMissionRoomRequirements** roomRequirements; AST(NAME("RoomRequirement"))
	UGCGenesisMissionChallengeRequirements** challengeRequirements; AST(NAME("ChallengeRequirement"))
	UGCGenesisMissionExtraVolume** extraVolumes;		AST(NAME("ExtraVolume"))

	UGCGenesisProceduralObjectParams* params;			AST(NAME("Params"))
} UGCGenesisMissionRequirements;
extern ParseTable parse_UGCGenesisMissionRequirements[];
#define TYPE_parse_UGCGenesisMissionRequirements UGCGenesisMissionRequirements

/// A door required for a mission
AUTO_STRUCT;
typedef struct UGCGenesisMissionDoorRequirements
{
	char* doorName;									AST(NAME("DoorName"))
} UGCGenesisMissionDoorRequirements;
extern ParseTable parse_UGCGenesisMissionDoorRequirements[];
#define TYPE_parse_UGCGenesisMissionDoorRequirements UGCGenesisMissionDoorRequirements

/// A concrete list of extra requirements a mission can impose on
/// rooms.
AUTO_STRUCT;
typedef struct UGCGenesisMissionRoomRequirements
{
	char* layoutName;								AST(NAME("LayoutName"))
	char* roomName;									AST(NAME("Name"))
	UGCGenesisMissionDoorRequirements** doors;			AST(NAME("Door"))
	UGCGenesisProceduralObjectParams* params;			AST(NAME("Params"))
} UGCGenesisMissionRoomRequirements;
extern ParseTable parse_UGCGenesisMissionRoomRequirements[];
#define TYPE_parse_UGCGenesisMissionRoomRequirements UGCGenesisMissionRoomRequirements

AUTO_STRUCT;
typedef struct UGCGenesisMissionPromptExprPair
{
	char* name;										AST(NAME("Name"))
	char* exprText;									AST(NAME("ExprText"))
} UGCGenesisMissionPromptExprPair;
extern ParseTable parse_UGCGenesisMissionPromptExprPair[];
#define TYPE_parse_UGCGenesisMissionPromptExprPair UGCGenesisMissionPromptExprPair

AUTO_STRUCT;
typedef struct UGCGenesisMissionContactRequirements
{
	DisplayMessage contactName;						AST(NAME("ContactName") STRUCT(parse_DisplayMessage) )
	UGCGenesisMissionPromptExprPair **eaPrompts;		AST(NAME("Prompts"))
	REF_TO(PlayerCostume) hCostume;					AST(NAME("Costume"))
	char *pcContactFileName;						AST(NAME("ContactFileName"))
} UGCGenesisMissionContactRequirements;
extern ParseTable parse_UGCGenesisMissionContactRequirements[];
#define TYPE_parse_UGCGenesisMissionContactRequirements UGCGenesisMissionContactRequirements

/// A wrapper for a struct which contains fields to override on a
/// specific challenge.
AUTO_STRUCT;
typedef struct UGCGenesisMissionChallengeRequirements
{
	char* challengeName;							AST(NAME("Name"))
	UGCGenesisInstancedObjectParams* params;			AST(NAME("Params"))
	UGCGenesisInteractObjectParams* interactParams;	AST(NAME("InteractParams"))
	UGCGenesisProceduralObjectParams *volumeParams;	AST(NAME("VolumeParams"))
} UGCGenesisMissionChallengeRequirements;
extern ParseTable parse_UGCGenesisMissionChallengeRequirements[];
#define TYPE_parse_UGCGenesisMissionChallengeRequirements UGCGenesisMissionChallengeRequirements

/// A definition for an extra volume to be placed in the world that
/// the mission requires
AUTO_STRUCT;
typedef struct UGCGenesisMissionExtraVolume {
	char* volumeName;								AST(NAME("Name"))

	// this names challenges or rooms
	char** objects;									AST(NAME("Object"))
} UGCGenesisMissionExtraVolume;
extern ParseTable parse_UGCGenesisMissionExtraVolume[];
#define TYPE_parse_UGCGenesisMissionExtraVolume UGCGenesisMissionExtraVolume

// TomY ENCOUNTER_HACK hacky hack continued
AUTO_STRUCT;
typedef struct UGCGenesisProceduralEncounterProperties
{
	const char *encounter_name;						AST( NAME(EncounterName) POOL_STRING )
	char *genesis_mission_name;						AST( NAME(MissionName) )
	int genesis_mission_num;						AST( NAME(MissionNum) )
	bool genesis_open_mission;						AST( NAME(OpenMission) )
	bool has_patrol;								AST( NAME(HasPatrol) )

	// Needs to work without UGCGenesis data, keep the challenges around.
	UGCGenesisWhen spawn_when;							AST( EMBEDDED_FLAT )
	UGCGenesisMissionZoneChallenge **when_challenges;	AST( NAME(SpawnWhenChallenge) )
} UGCGenesisProceduralEncounterProperties;
extern ParseTable parse_UGCGenesisProceduralEncounterProperties[];
#define TYPE_parse_UGCGenesisProceduralEncounterProperties UGCGenesisProceduralEncounterProperties

AUTO_STRUCT;
typedef struct UGCGenesisMissionVolumePoints
{
	char *volume_name;								AST( NAME(VolumeName) )
	F32 *positions;									AST( NAME(VolumePositions) )//Array of Vec3's
} UGCGenesisMissionVolumePoints;
extern ParseTable parse_UGCGenesisMissionVolumePoints[];
#define TYPE_parse_UGCGenesisMissionVolumePoints UGCGenesisMissionVolumePoints


//////////////////////////////////////////////////////////////////////////
// RoomDef Library
//////////////////////////////////////////////////////////////////////////

// The definition of an Interior room or an Exterior clearing
//
// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisRoomDef
{
	char *name;								AST(NAME("Name") KEY)
} UGCGenesisRoomDef;
extern ParseTable parse_UGCGenesisRoomDef[];
#define TYPE_parse_UGCGenesisRoomDef UGCGenesisRoomDef

//////////////////////////////////////////////////////////////////////////
// PathDef Library
//////////////////////////////////////////////////////////////////////////

// The definition of an Interior hallway or an Exterior path
//
// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisPathDef
{
	char *name;								AST(NAME("Name") KEY)
} UGCGenesisPathDef;
extern ParseTable parse_UGCGenesisPathDef[];
#define TYPE_parse_UGCGenesisPathDef UGCGenesisPathDef

//////////////////////////////////////////////////////////////////////////
// Layout embedded in a Zone Map
//////////////////////////////////////////////////////////////////////////

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisZoneMapRoom
{
	UGCGenesisRoomDef room;						AST(EMBEDDED_FLAT)
} UGCGenesisZoneMapRoom;
extern ParseTable parse_UGCGenesisZoneMapRoom[];
#define TYPE_parse_UGCGenesisZoneMapRoom UGCGenesisZoneMapRoom

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisZoneMapPath
{
	UGCGenesisPathDef path;						AST(EMBEDDED_FLAT)
} UGCGenesisZoneMapPath;
extern ParseTable parse_UGCGenesisZoneMapPath[];
#define TYPE_parse_UGCGenesisZoneMapPath UGCGenesisZoneMapPath

//////////////////////////////////////////////////////////////////////////
// Interior Layout in a Zone Map
//////////////////////////////////////////////////////////////////////////

AUTO_STRUCT;
typedef struct UGCGenesisZoneInterior
{
	char *layout_name;								AST(NAME("LayoutName"))

	UGCGenesisZoneMapRoom **rooms;					AST(NAME("Room"))
	UGCGenesisZoneMapPath **paths;					AST(NAME("Path"))

	bool override_positions;						AST(NAME("OverridePositions"))
} UGCGenesisZoneInterior;
extern ParseTable parse_UGCGenesisZoneInterior[];
#define TYPE_parse_UGCGenesisZoneInterior UGCGenesisZoneInterior

//////////////////////////////////////////////////////////////////////////
// Structures shared between phases
//////////////////////////////////////////////////////////////////////////

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisShoeboxPoint
{
	char *name;									AST(NAME("Name")) //Name to be used in Mission Desc File
} UGCGenesisShoeboxPoint;
extern ParseTable parse_UGCGenesisShoeboxPoint[];
#define TYPE_parse_UGCGenesisShoeboxPoint UGCGenesisShoeboxPoint

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisShoeboxPointList
{
	UGCGenesisShoeboxPoint **points;			AST(NAME("Point"))
} UGCGenesisShoeboxPointList;
extern ParseTable parse_UGCGenesisShoeboxPointList[];
#define TYPE_parse_UGCGenesisShoeboxPointList UGCGenesisShoeboxPointList

//////////////////////////////////////////////////////////////////////////
// Structs used at the Zone Map Phase
//////////////////////////////////////////////////////////////////////////

AUTO_STRUCT;
typedef struct UGCGenesisShoebox
{
	UGCGenesisShoeboxPointList **point_lists;	AST(NAME("PointList"))

	Vec3 overview_pos;							//Filled in when zmap is binned
	Vec3 layer_center;							NO_AST
	Vec3 layer_min;								NO_AST
	Vec3 layer_max;								NO_AST
} UGCGenesisShoebox;
extern ParseTable parse_UGCGenesisShoebox[];
#define TYPE_parse_UGCGenesisShoebox UGCGenesisShoebox

//This would be embedded inside a zone map
AUTO_STRUCT;
typedef struct UGCGenesisSolSysZoneMap
{
	char *layout_name;							AST(NAME("LayoutName"))
	UGCGenesisShoebox shoebox;					AST(NAME("Shoebox"))
} UGCGenesisSolSysZoneMap;
extern ParseTable parse_UGCGenesisSolSysZoneMap[];
#define TYPE_parse_UGCGenesisSolSysZoneMap UGCGenesisSolSysZoneMap

//////////////////////////////////////////////////////////////////////////
// Structs used at the Just Written Phase
//////////////////////////////////////////////////////////////////////////

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisGeotypeNodeData
{
	U8 no_water : 1;								AST(NAME("NoWater"))
} UGCGenesisGeotypeNodeData;
extern ParseTable parse_UGCGenesisGeotypeNodeData[];
#define TYPE_parse_UGCGenesisGeotypeNodeData UGCGenesisGeotypeNodeData

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisGeotype
{
	UGCGenesisGeotypeNodeData node_data;				AST(NAME("NodeData"))
} UGCGenesisGeotype;
extern ParseTable parse_UGCGenesisGeotype[];
#define TYPE_parse_UGCGenesisGeotype UGCGenesisGeotype

//////////////////////////////////////////////////////////////////////////
// Exterior Layout in a Zone Map
//////////////////////////////////////////////////////////////////////////

// High-level "Room Layout" model
AUTO_STRUCT;
typedef struct UGCGenesisZoneExterior
{
	char *layout_name;								AST(NAME("LayoutName"))

	UGCGenesisZoneMapRoom **rooms;						AST(NAME("Room"))
	UGCGenesisZoneMapPath **paths;						AST(NAME("Path"))
} UGCGenesisZoneExterior;
extern ParseTable parse_UGCGenesisZoneExterior[];
#define TYPE_parse_UGCGenesisZoneExterior UGCGenesisZoneExterior

// Placed 3D nodes, which can be edited
AUTO_STRUCT;
typedef struct UGCGenesisZoneNodeLayout
{
	char *layout_name;								AST(NAME("LayoutName"))
	SkyInfoGroup* sky_info;							AST(NAME("SkyInfo"))
	const char* amb_sound;							AST(NAME("AmbSound"))

	Vec2 play_min;									AST(NAME("PlayAreaMin"))
	Vec2 play_max;									AST(NAME("PlayAreaMax"))
	Vec2 play_heights;								AST(NAME("PlayHeights"))
	F32 play_buffer;								AST(NAME("PlayAreaBuffer"))

	ZoneMapEncounterRoomInfo **room_partitions;		NO_AST
} UGCGenesisZoneNodeLayout;
extern ParseTable parse_UGCGenesisZoneNodeLayout[];
#define TYPE_parse_UGCGenesisZoneNodeLayout UGCGenesisZoneNodeLayout

//////////////////////////////////////////////////////////////////////////
// "Just Written" Exterior Layout
//////////////////////////////////////////////////////////////////////////

// MJF (Sep/7/2012): This structure is probably dead.  However some
// code still is referencing it.
AUTO_STRUCT;
typedef struct UGCGenesisEcosystem
{
	char *name;								AST(NAME("Name") KEY  USERFLAG(TOK_USEROPTIONBIT_1))
	char *water_name;						AST(NAME("WaterPlane"))
	GroupDefRef **placed_objects;			AST(NAME("JustPlacedObject"))
} UGCGenesisEcosystem;
extern ParseTable parse_UGCGenesisEcosystem[];
#define TYPE_parse_UGCGenesisEcosystem UGCGenesisEcosystem

AUTO_STRUCT;
typedef struct GenesisZoneSharedUGCMission
{
	char *mission_name;								AST(NAME("Name"))
	UGCGenesisObject **objects;						AST(NAME("Object"))
} GenesisZoneSharedUGCMission;
extern ParseTable parse_GenesisZoneSharedUGCMission[];
#define TYPE_parse_GenesisZoneSharedUGCMission GenesisZoneSharedUGCMission

AUTO_STRUCT;
typedef struct UGCGenesisZoneShared
{
	char *layout_name;								AST(NAME("LayoutName"))
	U32 layout_seed;								AST(NAME("LayoutSeed"))
	U32 tmog_version;								AST(NAME("TransmogrifyVersion"))

	UGCGenesisObject **objects;						AST(NAME("Object"))
	GenesisZoneSharedUGCMission **missions;			AST(NAME("Mission"))

	SkyInfoGroup* sky_group;						AST(NAME("SkyGroup"))
	char* amb_sound;								AST(NAME("AmbSound"))

	const char *external_map_name;					AST(NAME("ExternalMapName") POOL_STRING)
	const char *external_region_name;				AST(NAME("ExternalRegionName") POOL_STRING)
} UGCGenesisZoneShared;
extern ParseTable parse_UGCGenesisZoneShared[];
#define TYPE_parse_UGCGenesisZoneShared UGCGenesisZoneShared
