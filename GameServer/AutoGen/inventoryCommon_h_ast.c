#include "textparser.h"

//auto-generated staticdefine for enum InvBagFlag
//autogeneratednocheckin
StaticDefineInt InvBagFlagEnum[] =
{
	DEFINE_INT
	{ "StorageOnly", InvBagFlag_StorageOnly},
	{ "EquipBag", InvBagFlag_EquipBag},
	{ "WeaponBag", InvBagFlag_WeaponBag},
	{ "DeviceBag", InvBagFlag_DeviceBag},
	{ "PlayerBag", InvBagFlag_PlayerBag},
	{ "PlayerBagIndex", InvBagFlag_PlayerBagIndex},
	{ "Hidden", InvBagFlag_Hidden},
	{ "NameIndexed", InvBagFlag_NameIndexed},
	{ "SellEnabled", InvBagFlag_SellEnabled},
	{ "BankBag", InvBagFlag_BankBag},
	{ "GuildBankBag", InvBagFlag_GuildBankBag},
	{ "NoCopy", InvBagFlag_NoCopy},
	{ "RecipeBag", InvBagFlag_RecipeBag},
	{ "NoModifyInCombat", InvBagFlag_NoModifyInCombat},
	{ "CostumeHideable", InvBagFlag_CostumeHideable},
	{ "ActiveWeaponBag", InvBagFlag_ActiveWeaponBag},
	{ "DefaultReady", InvBagFlag_DefaultReady},
	{ "CostumeHideablePerSlot", InvBagFlag_CostumeHideablePerSlot},
	{ "BoundPetStorage", InvBagFlag_BoundPetStorage},
	{ "ShowInAllCostumeSets", InvBagFlag_ShowInAllCostumeSets},
	{ "RestrictedOnly", InvBagFlag_RestrictedOnly},
	{ "DisallowClickPowers", InvBagFlag_DisallowClickPowers},
	DEFINE_END
};
void autoEnum_fixup_InvBagFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(InvBagFlagEnum, "InvBagFlag");
}

//auto-generated staticdefine for enum InventorySlotType
//autogeneratednocheckin
StaticDefineInt InventorySlotTypeEnum[] =
{
	DEFINE_INT
	{ "Empty", InventorySlotType_Empty},
	{ "Item", InventorySlotType_Item},
	{ "ItemLite", InventorySlotType_ItemLite},
	DEFINE_END
};
void autoEnum_fixup_InventorySlotType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(InventorySlotTypeEnum, "InventorySlotType");
}

//auto-generated staticdefine for enum InvBagType
//autogeneratednocheckin
StaticDefineInt InvBagTypeEnum[] =
{
	DEFINE_INT
	{ "None", InvBagType_None},
	{ "Item", InvBagType_Item},
	{ "ItemLite", InvBagType_ItemLite},
	DEFINE_END
};
void autoEnum_fixup_InvBagType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(InvBagTypeEnum, "InvBagType");
}

//auto-generated staticdefine for enum ItemAddFlags
//autogeneratednocheckin
StaticDefineInt ItemAddFlagsEnum[] =
{
	DEFINE_INT
	{ "Silent", ItemAdd_Silent},
	{ "OverrideStackRules", ItemAdd_OverrideStackRules},
	{ "IgnoreUnique", ItemAdd_IgnoreUnique},
	{ "ForceBind", ItemAdd_ForceBind},
	{ "UseOverflow", ItemAdd_UseOverflow},
	{ "FromBuybackOkay", ItemAdd_FromBuybackOkay},
	{ "ClearID", ItemAdd_ClearID},
	DEFINE_END
};
void autoEnum_fixup_ItemAddFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemAddFlagsEnum, "ItemAddFlags");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagExtraID
#define TYPE_parse_InvBagExtraID InvBagExtraID
ParseTable parse_InvBagExtraID[] =
{
	{ "InvBagExtraID", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagExtraID), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Names",				TOK_STRUCTPARAM | TOK_STRINGARRAY(InvBagExtraID, ppNames), NULL },
	{ "CanAffectCostume",	TOK_AUTOINT(InvBagExtraID, bCanAffectCostume, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagExtraID()
{
	int iSize = sizeof(InvBagExtraID);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagExtraID, iSize, "InvBagExtraID", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvBagExtraID[];
#define TYPE_parse_InvBagExtraID InvBagExtraID
//Structparser.exe autogenerated ParseTable for struct InvBagExtraIDs
#define TYPE_parse_InvBagExtraIDs InvBagExtraIDs
ParseTable parse_InvBagExtraIDs[] =
{
	{ "InvBagExtraIDs", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagExtraIDs), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "ID",				TOK_STRUCT(InvBagExtraIDs, ppIDs, parse_InvBagExtraID) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagExtraIDs()
{
	int iSize = sizeof(InvBagExtraIDs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagExtraIDs, iSize, "InvBagExtraIDs", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InventoryBagArray
#define TYPE_parse_InventoryBagArray InventoryBagArray
ParseTable parse_InventoryBagArray[] =
{
	{ "InventoryBagArray", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryBagArray), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "eaiBagArray",		TOK_INTARRAY(InventoryBagArray, eaiBagArray),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventoryBagArray()
{
	int iSize = sizeof(InventoryBagArray);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryBagArray, iSize, "InventoryBagArray", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
//Structparser.exe autogenerated ParseTable for struct InventoryBagGroup
#define TYPE_parse_InventoryBagGroup InventoryBagGroup
ParseTable parse_InventoryBagGroup[] =
{
	{ "InventoryBagGroup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryBagGroup), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Bags",				TOK_NO_INDEX | TOK_STRUCT(InventoryBagGroup, eaBags, parse_InventoryBag) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventoryBagGroup()
{
	int iSize = sizeof(InventoryBagGroup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryBagGroup, iSize, "InventoryBagGroup", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InventorySlotIDDef
#define TYPE_parse_InventorySlotIDDef InventorySlotIDDef
ParseTable parse_InventorySlotIDDef[] =
{
	{ "InventorySlotIDDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventorySlotIDDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Key",				TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(InventorySlotIDDef, pchKey, 0), NULL },
	{ "Icon",				TOK_STRING(InventorySlotIDDef, pchIcon, 0), NULL },
	{ "MainBagID",			TOK_AUTOINT(InventorySlotIDDef, eMainBagID, 0), InvBagIDsEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventorySlotIDDef()
{
	int iSize = sizeof(InventorySlotIDDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventorySlotIDDef, iSize, "InventorySlotIDDef", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvSlotIDContainer
#define TYPE_parse_InvSlotIDContainer InvSlotIDContainer
ParseTable parse_InvSlotIDContainer[] =
{
	{ "InvSlotIDContainer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvSlotIDContainer), 0, NULL, 0, NULL },
	{ "hSlot",				TOK_STRUCTPARAM | TOK_REFERENCE(InvSlotIDContainer, hSlot, 0, "InventorySlotIDDef") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvSlotIDContainer()
{
	int iSize = sizeof(InvSlotIDContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvSlotIDContainer, iSize, "InvSlotIDContainer", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Item[];
#define TYPE_parse_Item Item
//Structparser.exe autogenerated ParseTable for struct InventorySlot
#define TYPE_parse_InventorySlot InventorySlot
ParseTable parse_InventorySlot[] =
{
	{ "InventorySlot", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventorySlot), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "pchName",		TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_STRING(InventorySlot, pchName, 0), NULL },
	{ "pItem",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(InventorySlot, pItem, parse_Item) },
	{ "hSlotType",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventorySlot, hSlotType, 0, "InventorySlotIDDef") },
	{ "bHideCostumes",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_InventorySlot()
{
	int iSize = sizeof(InventorySlot);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventorySlot, iSize, "InventorySlot", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(InventorySlot)) + 7) / 4;
		NOCONST(InventorySlot) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHideCostumes = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InventorySlot[5]);
		pTemp->bHideCostumes = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemV1[];
#define TYPE_parse_ItemV1 ItemV1
//Structparser.exe autogenerated ParseTable for struct InventorySlotV1
#define TYPE_parse_InventorySlotV1 InventorySlotV1
ParseTable parse_InventorySlotV1[] =
{
	{ "InventorySlotV1", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventorySlotV1), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchName",			TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_STRING(InventorySlotV1, pchName, 0), NULL },
	{ "Type",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventorySlotV1, Type, 0), InventorySlotTypeEnum },
	{ "count",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventorySlotV1, count, 0), NULL },
	{ "pItem",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(InventorySlotV1, pItem, parse_ItemV1) },
	{ "hItemDef",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventorySlotV1, hItemDef, 0, "ItemDef") },
	{ "hSlotType",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventorySlotV1, hSlotType, 0, "InventorySlotIDDef") },
	{ "bHideCostumes",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_InventorySlotV1()
{
	int iSize = sizeof(InventorySlotV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventorySlotV1, iSize, "InventorySlotV1", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(InventorySlotV1)) + 7) / 4;
		NOCONST(InventorySlotV1) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHideCostumes = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InventorySlotV1[8]);
		pTemp->bHideCostumes = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagSlotSwitchRequest
#define TYPE_parse_InvBagSlotSwitchRequest InvBagSlotSwitchRequest
ParseTable parse_InvBagSlotSwitchRequest[] =
{
	{ "InvBagSlotSwitchRequest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagSlotSwitchRequest), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "BagID",						TOK_AUTOINT(InvBagSlotSwitchRequest, eBagID, 0), InvBagIDsEnum },
	{ "Index",						TOK_AUTOINT(InvBagSlotSwitchRequest, iIndex, 0), NULL },
	{ "NewActiveSlot",				TOK_AUTOINT(InvBagSlotSwitchRequest, iNewActiveSlot, 0), NULL },
	{ "uRequestID",					TOK_AUTOINT(InvBagSlotSwitchRequest, uRequestID, 0), NULL },
	{ "uTime",						TOK_AUTOINT(InvBagSlotSwitchRequest, uTime, 0), NULL },
	{ "Delay",						TOK_F32(InvBagSlotSwitchRequest, fDelay, 0), NULL },
	{ "Timer",						TOK_F32(InvBagSlotSwitchRequest, fTimer, 0), NULL },
	{ "HasChangedSlot",				TOK_AUTOINT(InvBagSlotSwitchRequest, bHasChangedSlot, 0), NULL },
	{ "HasHandledMoveEvents",		TOK_AUTOINT(InvBagSlotSwitchRequest, bHasHandledMoveEvents, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagSlotSwitchRequest()
{
	int iSize = sizeof(InvBagSlotSwitchRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagSlotSwitchRequest, iSize, "InvBagSlotSwitchRequest", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InventorySlotLite
#define TYPE_parse_InventorySlotLite InventorySlotLite
ParseTable parse_InventorySlotLite[] =
{
	{ "InventorySlotLite", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventorySlotLite), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchName",			TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_STRING(InventorySlotLite, pchName, 0), NULL },
	{ "count",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventorySlotLite, count, 1), NULL },
	{ "hItemDef",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(InventorySlotLite, hItemDef, 0, "ItemDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventorySlotLite()
{
	int iSize = sizeof(InventorySlotLite);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventorySlotLite, iSize, "InventorySlotLite", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventorySlotLite[];
#define TYPE_parse_InventorySlotLite InventorySlotLite
extern ParseTable parse_GuildBankTabInfo[];
#define TYPE_parse_GuildBankTabInfo GuildBankTabInfo
//Structparser.exe autogenerated ParseTable for struct InventoryBagLite
#define TYPE_parse_InventoryBagLite InventoryBagLite
ParseTable parse_InventoryBagLite[] =
{
	{ "InventoryBagLite", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryBagLite), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "BagID",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_AUTOINT(InventoryBagLite, BagID, 0), InvBagIDsEnum },
	{ "inv_def",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventoryBagLite, inv_def, 0, "DefaultInventory") },
	{ "ppIndexedLiteSlots",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(InventoryBagLite, ppIndexedLiteSlots, parse_InventorySlotLite) },
	{ "pGuildBankInfo",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(InventoryBagLite, pGuildBankInfo, parse_GuildBankTabInfo) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventoryBagLite()
{
	int iSize = sizeof(InventoryBagLite);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryBagLite, iSize, "InventoryBagLite", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct OwnedUniqueItem
#define TYPE_parse_OwnedUniqueItem OwnedUniqueItem
ParseTable parse_OwnedUniqueItem[] =
{
	{ "OwnedUniqueItem", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(OwnedUniqueItem), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "pchName",			TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_STRING(OwnedUniqueItem, pchName, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_OwnedUniqueItem()
{
	int iSize = sizeof(OwnedUniqueItem);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_OwnedUniqueItem, iSize, "OwnedUniqueItem", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NewItemID
#define TYPE_parse_NewItemID NewItemID
ParseTable parse_NewItemID[] =
{
	{ "NewItemID", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NewItemID), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "id",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_KEY | TOK_AUTOINT(NewItemID, id, 0), NULL },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_NewItemID()
{
	int iSize = sizeof(NewItemID);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NewItemID, iSize, "NewItemID", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
extern ParseTable parse_InventoryBagLite[];
#define TYPE_parse_InventoryBagLite InventoryBagLite
extern ParseTable parse_OwnedUniqueItem[];
#define TYPE_parse_OwnedUniqueItem OwnedUniqueItem
extern ParseTable parse_InvBagSlotSwitchRequest[];
#define TYPE_parse_InvBagSlotSwitchRequest InvBagSlotSwitchRequest
extern ParseTable parse_NewItemID[];
#define TYPE_parse_NewItemID NewItemID
//Structparser.exe autogenerated ParseTable for struct Inventory
#define TYPE_parse_Inventory Inventory
ParseTable parse_Inventory[] =
{
	{ "Inventory", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Inventory), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "dirtyBit",				TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(Inventory, dirtyBit, 0), NULL },
	{ "inv_def",				TOK_REFERENCE(Inventory, inv_def, 0, "DefaultInventory") },
	{ "ppInventoryBags",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(Inventory, ppInventoryBags, parse_InventoryBag) },
	{ "ppLiteBags",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(Inventory, ppLiteBags, parse_InventoryBagLite) },
	{ "peaOwnedUniqueItems",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(Inventory, peaOwnedUniqueItems, parse_OwnedUniqueItem) },
	{ "ppSlotSwitchRequest",	TOK_NO_NETSEND | TOK_STRUCT(Inventory, ppSlotSwitchRequest, parse_InvBagSlotSwitchRequest) },
	{ "uiCurrentSlotSwitchID",	TOK_CLIENT_ONLY | TOK_AUTOINT(Inventory, uiCurrentSlotSwitchID, 0), NULL },
	{ "eaiNewItemIDs",			TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_STRUCT(Inventory, eaiNewItemIDs, parse_NewItemID) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_Inventory()
{
	int iSize = sizeof(Inventory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Inventory, iSize, "Inventory", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBagV1[];
#define TYPE_parse_InventoryBagV1 InventoryBagV1
extern ParseTable parse_InvBagSlotSwitchRequest[];
#define TYPE_parse_InvBagSlotSwitchRequest InvBagSlotSwitchRequest
//Structparser.exe autogenerated ParseTable for struct InventoryV1
#define TYPE_parse_InventoryV1 InventoryV1
ParseTable parse_InventoryV1[] =
{
	{ "InventoryV1", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryV1), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "dirtyBit",				TOK_DIRTY_BIT | TOK_NO_NETSEND | TOK_AUTOINT(InventoryV1, dirtyBit, 0), NULL },
	{ "inv_def",				TOK_REFERENCE(InventoryV1, inv_def, 0, "DefaultInventory") },
	{ "ppInventoryBags",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(InventoryV1, ppInventoryBags, parse_InventoryBagV1) },
	{ "ppSlotSwitchRequest",	TOK_NO_NETSEND | TOK_STRUCT(InventoryV1, ppSlotSwitchRequest, parse_InvBagSlotSwitchRequest) },
	{ "uiCurrentSlotSwitchID",	TOK_CLIENT_ONLY | TOK_AUTOINT(InventoryV1, uiCurrentSlotSwitchID, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventoryV1()
{
	int iSize = sizeof(InventoryV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryV1, iSize, "InventoryV1", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagItemMoveEvent
#define TYPE_parse_InvBagItemMoveEvent InvBagItemMoveEvent
ParseTable parse_InvBagItemMoveEvent[] =
{
	{ "InvBagItemMoveEvent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagItemMoveEvent), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "FlashBits",				TOK_POOL_STRING | TOK_STRINGARRAY(InvBagItemMoveEvent, ppchFlashBits), NULL },
	{ "PowerCooldownCategory",	TOK_POOL_STRING | TOK_STRING(InvBagItemMoveEvent, pchPowerCooldownCategory, 0), NULL },
	{ "CooldownTime",			TOK_F32(InvBagItemMoveEvent, fCooldownTime, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagItemMoveEvent()
{
	int iSize = sizeof(InvBagItemMoveEvent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagItemMoveEvent, iSize, "InvBagItemMoveEvent", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagDefItemArt
#define TYPE_parse_InvBagDefItemArt InvBagDefItemArt
ParseTable parse_InvBagDefItemArt[] =
{
	{ "InvBagDefItemArt", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagDefItemArt), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "FX",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(InvBagDefItemArt, pchFX, 0), NULL },
	{ "Bone",				TOK_POOL_STRING | TOK_STRING(InvBagDefItemArt, pchBone, 0), NULL },
	{ "Position",			TOK_VEC3(InvBagDefItemArt, vPosition), NULL },
	{ "Rotation",			TOK_VEC3(InvBagDefItemArt, vRotation), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagDefItemArt()
{
	int iSize = sizeof(InvBagDefItemArt);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagDefItemArt, iSize, "InvBagDefItemArt", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct InvBagCategory
#define TYPE_parse_InvBagCategory InvBagCategory
ParseTable parse_InvBagCategory[] =
{
	{ "InvBagCategory", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagCategory), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(InvBagCategory, pchName, 0), NULL },
	{ "DisplayName",	TOK_EMBEDDEDSTRUCT(InvBagCategory, msgDisplayName, parse_DisplayMessage)},
	{ "BagID",			TOK_INTARRAY(InvBagCategory, peBagIDs),  InvBagIDsEnum},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagCategory()
{
	int iSize = sizeof(InvBagCategory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagCategory, iSize, "InvBagCategory", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvBagCategory[];
#define TYPE_parse_InvBagCategory InvBagCategory
//Structparser.exe autogenerated ParseTable for struct InvBagCategories
#define TYPE_parse_InvBagCategories InvBagCategories
ParseTable parse_InvBagCategories[] =
{
	{ "InvBagCategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagCategories), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "BagCategory",		TOK_STRUCT(InvBagCategories, eaCategories, parse_InvBagCategory) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagCategories()
{
	int iSize = sizeof(InvBagCategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagCategories, iSize, "InvBagCategories", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagSlotTableEntry
#define TYPE_parse_InvBagSlotTableEntry InvBagSlotTableEntry
ParseTable parse_InvBagSlotTableEntry[] =
{
	{ "InvBagSlotTableEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagSlotTableEntry), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "NumericValue",			TOK_STRUCTPARAM | TOK_AUTOINT(InvBagSlotTableEntry, iNumericValue, 0), NULL },
	{ "MaxSlots",				TOK_AUTOINT(InvBagSlotTableEntry, iMaxSlots, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagSlotTableEntry()
{
	int iSize = sizeof(InvBagSlotTableEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagSlotTableEntry, iSize, "InvBagSlotTableEntry", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvBagSlotTableEntry[];
#define TYPE_parse_InvBagSlotTableEntry InvBagSlotTableEntry
//Structparser.exe autogenerated ParseTable for struct InvBagSlotTable
#define TYPE_parse_InvBagSlotTable InvBagSlotTable
ParseTable parse_InvBagSlotTable[] =
{
	{ "InvBagSlotTable", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagSlotTable), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(InvBagSlotTable, pchName, 0), NULL },
	{ "Value",				TOK_STRUCT(InvBagSlotTable, eaEntries, parse_InvBagSlotTableEntry) },
	{ "NumericValue",		TOK_REDUNDANTNAME | TOK_STRUCT(InvBagSlotTable, eaEntries, parse_InvBagSlotTableEntry) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagSlotTable()
{
	int iSize = sizeof(InvBagSlotTable);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagSlotTable, iSize, "InvBagSlotTable", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvBagSlotTable[];
#define TYPE_parse_InvBagSlotTable InvBagSlotTable
//Structparser.exe autogenerated ParseTable for struct InvBagSlotTables
#define TYPE_parse_InvBagSlotTables InvBagSlotTables
ParseTable parse_InvBagSlotTables[] =
{
	{ "InvBagSlotTables", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagSlotTables), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "BagSlotTable",		TOK_STRUCT(InvBagSlotTables, eaTables, parse_InvBagSlotTable) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagSlotTables()
{
	int iSize = sizeof(InvBagSlotTables);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagSlotTables, iSize, "InvBagSlotTables", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvBagVariableMaxSlotDef
#define TYPE_parse_InvBagVariableMaxSlotDef InvBagVariableMaxSlotDef
ParseTable parse_InvBagVariableMaxSlotDef[] =
{
	{ "InvBagVariableMaxSlotDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagVariableMaxSlotDef), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "MaxSlotTable",					TOK_STRING(InvBagVariableMaxSlotDef, pchMaxSlotTable, 0), NULL },
	{ "MaxSlotTableNumericStandard",	TOK_REFERENCE(InvBagVariableMaxSlotDef, hMaxSlotTableNumericStandard, 0, "ItemDef") },
	{ "MaxSlotTableNumericPremium",		TOK_REFERENCE(InvBagVariableMaxSlotDef, hMaxSlotTableNumericPremium, 0, "ItemDef") },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvBagVariableMaxSlotDef()
{
	int iSize = sizeof(InvBagVariableMaxSlotDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagVariableMaxSlotDef, iSize, "InvBagVariableMaxSlotDef", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvSlotIDContainer[];
#define TYPE_parse_InvSlotIDContainer InvSlotIDContainer
extern ParseTable parse_InvBagVariableMaxSlotDef[];
#define TYPE_parse_InvBagVariableMaxSlotDef InvBagVariableMaxSlotDef
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_InvBagDefItemArt[];
#define TYPE_parse_InvBagDefItemArt InvBagDefItemArt
extern ParseTable parse_InvBagDefItemArt[];
#define TYPE_parse_InvBagDefItemArt InvBagDefItemArt
extern ParseTable parse_InvBagDefItemArt[];
#define TYPE_parse_InvBagDefItemArt InvBagDefItemArt
extern ParseTable parse_InvBagDefItemArt[];
#define TYPE_parse_InvBagDefItemArt InvBagDefItemArt
extern ParseTable parse_InvBagItemMoveEvent[];
#define TYPE_parse_InvBagItemMoveEvent InvBagItemMoveEvent
//Structparser.exe autogenerated ParseTable for struct InvBagDef
#define TYPE_parse_InvBagDef InvBagDef
ParseTable parse_InvBagDef[] =
{
	{ "InvBagDef", 					TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvBagDef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "BagID",						TOK_STRUCTPARAM | TOK_KEY | TOK_AUTOINT(InvBagDef, BagID, 0), InvBagIDsEnum },
	{ "fname",						TOK_POOL_STRING | TOK_CURRENTFILE(InvBagDef, fname), NULL},
	{ "Type",						TOK_AUTOINT(InvBagDef, eType, 1), InvBagTypeEnum },
	{ "MaxSlots",					TOK_AUTOINT(InvBagDef, MaxSlots, -1), NULL },
	{ "SlotID",						TOK_STRUCT(InvBagDef, ppSlotIDs, parse_InvSlotIDContainer) },
	{ "flags",						TOK_AUTOINT(InvBagDef, flags, 0), InvBagFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "power_yaw",					TOK_F32(InvBagDef, power_yaw, 0), NULL },
	{ "not_in_default_inventory",	TOK_AUTOINT(InvBagDef, not_in_default_inventory, 0), NULL },
	{ "primaryMaxSlots", 			TOK_IGNORE | TOK_FLATEMBED },
	{ "MaxSlotTable",				TOK_STRING(InvBagDef, primaryMaxSlots.pchMaxSlotTable, 0), NULL },
	{ "MaxSlotTableNumericStandard",TOK_REFERENCE(InvBagDef, primaryMaxSlots.hMaxSlotTableNumericStandard, 0, "ItemDef") },
	{ "MaxSlotTableNumericPremium",	TOK_REFERENCE(InvBagDef, primaryMaxSlots.hMaxSlotTableNumericPremium, 0, "ItemDef") },
	{ "AdditionalMaxSlots",			TOK_STRUCT(InvBagDef, eaAdditionalMaxSlots, parse_InvBagVariableMaxSlotDef) },
	{ "additionalMaxSlotsLimit",	TOK_AUTOINT(InvBagDef, additionalMaxSlotsLimit, 0), NULL },
	{ "BagFullMessage",				TOK_EMBEDDEDSTRUCT(InvBagDef, msgBagFull, parse_DisplayMessage)},
	{ "maxActiveSlots",				TOK_AUTOINT(InvBagDef, maxActiveSlots, 1), NULL },
	{ "DefaultActiveSlot",			TOK_INTARRAY(InvBagDef, eaiDefaultActiveSlots),  NULL},
	{ "ItemArtActive",				TOK_OPTIONALSTRUCT(InvBagDef, pItemArtActive, parse_InvBagDefItemArt) },
	{ "FXItemArtActive",			TOK_REDUNDANTNAME | TOK_OPTIONALSTRUCT(InvBagDef, pItemArtActive, parse_InvBagDefItemArt) },
	{ "ItemArtInactive",			TOK_OPTIONALSTRUCT(InvBagDef, pItemArtInactive, parse_InvBagDefItemArt) },
	{ "FXItemArtInactive",			TOK_REDUNDANTNAME | TOK_OPTIONALSTRUCT(InvBagDef, pItemArtInactive, parse_InvBagDefItemArt) },
	{ "ItemArtActiveSecondary",		TOK_OPTIONALSTRUCT(InvBagDef, pItemArtActiveSecondary, parse_InvBagDefItemArt) },
	{ "SecondaryFXItemArtActive",	TOK_REDUNDANTNAME | TOK_OPTIONALSTRUCT(InvBagDef, pItemArtActiveSecondary, parse_InvBagDefItemArt) },
	{ "ItemArtInactiveSecondary",	TOK_OPTIONALSTRUCT(InvBagDef, pItemArtInactiveSecondary, parse_InvBagDefItemArt) },
	{ "SecondaryFXItemArtInactive",	TOK_REDUNDANTNAME | TOK_OPTIONALSTRUCT(InvBagDef, pItemArtInactiveSecondary, parse_InvBagDefItemArt) },
	{ "FXNodeName",					TOK_STRING(InvBagDef, pFXNodeName, 0), NULL },
	{ "ItemMoveEvent",				TOK_STRUCT(InvBagDef, ppItemMoveEvents, parse_InvBagItemMoveEvent) },
	{ "PrimaryOnlyCategories",		TOK_INTARRAY(InvBagDef, pePrimaryOnlyCategories),  ItemCategoryEnum},
	{ "ChangeActiveSlotDelay",		TOK_F32(InvBagDef, fChangeActiveSlotDelay, 0), NULL },
	{ "AutoAttack",					TOK_BIT, 0, 8, NULL},
	{ "UseItemsInInventoryFirst",	TOK_BIT, 0, 8, NULL},
	{ "FakePropSlots",				TOK_BIT, 0, 8, NULL},
	{ "CostumeSetIndex",			TOK_AUTOINT(InvBagDef, iCostumeSetIndex, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_InvBagDef()
{
	int iSize = sizeof(InvBagDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvBagDef, iSize, "InvBagDef", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(InvBagDef) + 7) / 4;
		InvBagDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bAutoAttack = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InvBagDef[31]);
		pTemp->bAutoAttack = 0;
		pTemp->bUseItemsInInventoryFirst = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InvBagDef[32]);
		pTemp->bUseItemsInInventoryFirst = 0;
		pTemp->bFakePropSlots = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InvBagDef[33]);
		pTemp->bFakePropSlots = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventorySlotV1[];
#define TYPE_parse_InventorySlotV1 InventorySlotV1
extern ParseTable parse_RewardBagInfo[];
#define TYPE_parse_RewardBagInfo RewardBagInfo
extern ParseTable parse_GuildBankTabInfo[];
#define TYPE_parse_GuildBankTabInfo GuildBankTabInfo
//Structparser.exe autogenerated ParseTable for struct InventoryBagV1
#define TYPE_parse_InventoryBagV1 InventoryBagV1
ParseTable parse_InventoryBagV1[] =
{
	{ "InventoryBagV1", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryBagV1), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "BagID",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_AUTOINT(InventoryBagV1, BagID, 0), InvBagIDsEnum },
	{ "inv_def",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventoryBagV1, inv_def, 0, "DefaultInventory") },
	{ "MaxSlots",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventoryBagV1, n_additional_slots, 0), NULL },
	{ "n_additional_slots",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventoryBagV1, n_additional_slots, 0), NULL },
	{ "ppIndexedInventorySlots",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(InventoryBagV1, ppIndexedInventorySlots, parse_InventorySlotV1) },
	{ "pRewardBagInfo",				TOK_OPTIONALSTRUCT(InventoryBagV1, pRewardBagInfo, parse_RewardBagInfo) },
	{ "pGuildBankInfo",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(InventoryBagV1, pGuildBankInfo, parse_GuildBankTabInfo) },
	{ "iActiveSlot",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_INTARRAY(InventoryBagV1, eaiActiveSlots),  NULL},
	{ "eaiActiveSlots",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_INTARRAY(InventoryBagV1, eaiActiveSlots),  NULL},
	{ "eaiPredictedActiveSlots",	TOK_CLIENT_ONLY | TOK_INTARRAY(InventoryBagV1, eaiPredictedActiveSlots),  NULL},
	{ "uiTeamOwner",				TOK_SERVER_ONLY | TOK_AUTOINT(InventoryBagV1, uiTeamOwner, 0), NULL },
	{ "bHideCostumes",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_InventoryBagV1()
{
	int iSize = sizeof(InventoryBagV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryBagV1, iSize, "InventoryBagV1", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(InventoryBagV1)) + 7) / 4;
		NOCONST(InventoryBagV1) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHideCostumes = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InventoryBagV1[13]);
		pTemp->bHideCostumes = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventorySlot[];
#define TYPE_parse_InventorySlot InventorySlot
extern ParseTable parse_RewardBagInfo[];
#define TYPE_parse_RewardBagInfo RewardBagInfo
extern ParseTable parse_GuildBankTabInfo[];
#define TYPE_parse_GuildBankTabInfo GuildBankTabInfo
//Structparser.exe autogenerated ParseTable for struct InventoryBag
#define TYPE_parse_InventoryBag InventoryBag
ParseTable parse_InventoryBag[] =
{
	{ "InventoryBag", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventoryBag), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "BagID",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_REQUIRED | TOK_AUTOINT(InventoryBag, BagID, 0), InvBagIDsEnum },
	{ "inv_def",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(InventoryBag, inv_def, 0, "DefaultInventory") },
	{ "MaxSlots",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventoryBag, n_additional_slots, 0), NULL },
	{ "n_additional_slots",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(InventoryBag, n_additional_slots, 0), NULL },
	{ "ppIndexedInventorySlots",	TOK_PERSIST | TOK_SELF_ONLY | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(InventoryBag, ppIndexedInventorySlots, parse_InventorySlot) },
	{ "pRewardBagInfo",				TOK_OPTIONALSTRUCT(InventoryBag, pRewardBagInfo, parse_RewardBagInfo) },
	{ "pGuildBankInfo",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(InventoryBag, pGuildBankInfo, parse_GuildBankTabInfo) },
	{ "iActiveSlot",				TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_INTARRAY(InventoryBag, eaiActiveSlots),  NULL},
	{ "eaiActiveSlots",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_NO_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_INTARRAY(InventoryBag, eaiActiveSlots),  NULL},
	{ "eaiPredictedActiveSlots",	TOK_CLIENT_ONLY | TOK_INTARRAY(InventoryBag, eaiPredictedActiveSlots),  NULL},
	{ "uiTeamOwner",				TOK_SERVER_ONLY | TOK_AUTOINT(InventoryBag, uiTeamOwner, 0), NULL },
	{ "bHideCostumes",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_InventoryBag()
{
	int iSize = sizeof(InventoryBag);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventoryBag, iSize, "InventoryBag", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(InventoryBag)) + 7) / 4;
		NOCONST(InventoryBag) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bHideCostumes = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_InventoryBag[13]);
		pTemp->bHideCostumes = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_aiModifierDef[];
#define TYPE_parse_aiModifierDef aiModifierDef
//Structparser.exe autogenerated ParseTable for struct DefaultItemDef
#define TYPE_parse_DefaultItemDef DefaultItemDef
ParseTable parse_DefaultItemDef[] =
{
	{ "DefaultItemDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DefaultItemDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Key",			TOK_KEY | TOK_AUTOINT(DefaultItemDef, iKey, 0), NULL },
	{ "Order",			TOK_F32(DefaultItemDef, fOrder, 0), NULL },
	{ "Item",			TOK_REFERENCE(DefaultItemDef, hItem, 0, "ItemDef") },
	{ "BagID",			TOK_AUTOINT(DefaultItemDef, eBagID, InvBagIDs_Inventory), InvBagIDsEnum },
	{ "Count",			TOK_AUTOINT(DefaultItemDef, iCount, 1), NULL },
	{ "ModifierInfo",	TOK_OPTIONALSTRUCT(DefaultItemDef, pModifierInfo, parse_aiModifierDef) },
	{ "MinLevel",		TOK_AUTOINT(DefaultItemDef, iMinLevel, -1), NULL },
	{ "MaxLevel",		TOK_AUTOINT(DefaultItemDef, iMaxLevel, -1), NULL },
	{ "Chance",			TOK_F32(DefaultItemDef, fChance, 1), NULL },
	{ "Group",			TOK_AUTOINT(DefaultItemDef, iGroup, 0), NULL },
	{ "Slot",			TOK_AUTOINT(DefaultItemDef, iSlot, -1), NULL },
	{ "Weight",			TOK_F32(DefaultItemDef, fWeight, 0), NULL },
	{ "Disabled",		TOK_AUTOINT(DefaultItemDef, bDisabled, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DefaultItemDef()
{
	int iSize = sizeof(DefaultItemDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DefaultItemDef, iSize, "DefaultItemDef", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_DefaultItemDef[10].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvBagDef[];
#define TYPE_parse_InvBagDef InvBagDef
extern ParseTable parse_DefaultItemDef[];
#define TYPE_parse_DefaultItemDef DefaultItemDef
//Structparser.exe autogenerated ParseTable for struct DefaultInventory
#define TYPE_parse_DefaultInventory DefaultInventory
ParseTable parse_DefaultInventory[] =
{
	{ "DefaultInventory", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DefaultInventory), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "InventoryName",		TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(DefaultInventory, pchInventoryName, 0), NULL },
	{ "InventoryBags",		TOK_STRUCT(DefaultInventory, InventoryBags, parse_InvBagDef) },
	{ "GrantItem",			TOK_STRUCT(DefaultInventory, GrantedItems, parse_DefaultItemDef) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DefaultInventory()
{
	int iSize = sizeof(DefaultInventory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DefaultInventory, iSize, "DefaultInventory", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InvRewardGrantData
#define TYPE_parse_InvRewardGrantData InvRewardGrantData
ParseTable parse_InvRewardGrantData[] =
{
	{ "InvRewardGrantData", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvRewardGrantData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "SpecialRewardStatus",	TOK_AUTOINT(InvRewardGrantData, iSpecialRewardStatus, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvRewardGrantData()
{
	int iSize = sizeof(InvRewardGrantData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvRewardGrantData, iSize, "InvRewardGrantData", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemNumericData[];
#define TYPE_parse_ItemNumericData ItemNumericData
extern ParseTable parse_Item[];
#define TYPE_parse_Item Item
extern ParseTable parse_InvRewardGrantData[];
#define TYPE_parse_InvRewardGrantData InvRewardGrantData
extern ParseTable parse_InventorySlot[];
#define TYPE_parse_InventorySlot InventorySlot
//Structparser.exe autogenerated ParseTable for struct InvRewardRequest
#define TYPE_parse_InvRewardRequest InvRewardRequest
ParseTable parse_InvRewardRequest[] =
{
	{ "InvRewardRequest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InvRewardRequest), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "NumericRewards",		TOK_STRUCT(InvRewardRequest, eaNumericRewards, parse_ItemNumericData) },
	{ "ItemRewards",		TOK_STRUCT(InvRewardRequest, eaItemRewards, parse_Item) },
	{ "GrantData",			TOK_STRUCT(InvRewardRequest, eaGrantData, parse_InvRewardGrantData) },
	{ "Rewards",			TOK_CLIENT_ONLY | TOK_STRUCT(InvRewardRequest, eaRewards, parse_InventorySlot) },
	{ "RewardSlots",		TOK_CLIENT_ONLY | TOK_AUTOINT(InvRewardRequest, iRewardSlots, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InvRewardRequest()
{
	int iSize = sizeof(InvRewardRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InvRewardRequest, iSize, "InvRewardRequest", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemTransCBData
#define TYPE_parse_ItemTransCBData ItemTransCBData
ParseTable parse_ItemTransCBData[] =
{
	{ "ItemTransCBData", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemTransCBData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ItemDefName",			TOK_STRING(ItemTransCBData, pchItemDefName, 0), NULL },
	{ "SoldItem",				TOK_POOL_STRING | TOK_STRING(ItemTransCBData, pchSoldItem, 0), NULL },
	{ "ppchNamesUntranslated",	TOK_STRINGARRAY(ItemTransCBData, ppchNamesUntranslated), NULL },
	{ "Count",					TOK_AUTOINT(ItemTransCBData, iCount, 0), NULL },
	{ "value",					TOK_AUTOINT(ItemTransCBData, value, 0), NULL },
	{ "type",					TOK_AUTOINT(ItemTransCBData, type, 0), NULL },
	{ "BagID",					TOK_AUTOINT(ItemTransCBData, eBagID, 0), InvBagIDsEnum },
	{ "BagSlot",				TOK_AUTOINT(ItemTransCBData, iBagSlot, 0), NULL },
	{ "kQuality",				TOK_AUTOINT(ItemTransCBData, kQuality, 0), NULL },
	{ "uiItemID",				TOK_AUTOINT(ItemTransCBData, uiItemID, 0), NULL },
	{ "Origin",					TOK_VEC3(ItemTransCBData, vOrigin), NULL },
	{ "TranslateName",			TOK_AUTOINT(ItemTransCBData, bTranslateName, 0), NULL },
	{ "Silent",					TOK_AUTOINT(ItemTransCBData, bSilent, 0), NULL },
	{ "FromRollover",			TOK_AUTOINT(ItemTransCBData, bFromRollover, 0), NULL },
	{ "fromStore",				TOK_AUTOINT(ItemTransCBData, bFromStore, 0), NULL },
	{ "Lite",					TOK_AUTOINT(ItemTransCBData, bLite, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemTransCBData()
{
	int iSize = sizeof(ItemTransCBData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemTransCBData, iSize, "ItemTransCBData", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemChangeReason
#define TYPE_parse_ItemChangeReason ItemChangeReason
ParseTable parse_ItemChangeReason[] =
{
	{ "ItemChangeReason", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemChangeReason), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Reason",				TOK_POOL_STRING | TOK_STRING(ItemChangeReason, pcReason, 0), NULL },
	{ "Detail",				TOK_POOL_STRING | TOK_STRING(ItemChangeReason, pcDetail, 0), NULL },
	{ "MapName",			TOK_POOL_STRING | TOK_STRING(ItemChangeReason, pcMapName, 0), NULL },
	{ "Pos",				TOK_VEC3(ItemChangeReason, vPos), NULL },
	{ "UGC",				TOK_BIT, 0, 8, NULL},
	{ "KillCredit",			TOK_BIT, 0, 8, NULL},
	{ "FromRollover",		TOK_BIT, 0, 8, NULL},
	{ "fromStore",			TOK_BIT, 0, 8, NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ItemChangeReason()
{
	int iSize = sizeof(ItemChangeReason);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemChangeReason, iSize, "ItemChangeReason", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(ItemChangeReason) + 7) / 4;
		ItemChangeReason *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bUGC = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemChangeReason[6]);
		pTemp->bUGC = 0;
		pTemp->bKillCredit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemChangeReason[7]);
		pTemp->bKillCredit = 0;
		pTemp->bFromRollover = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemChangeReason[8]);
		pTemp->bFromRollover = 0;
		pTemp->bFromStore = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemChangeReason[9]);
		pTemp->bFromStore = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MoveItemGuildStruct
#define TYPE_parse_MoveItemGuildStruct MoveItemGuildStruct
ParseTable parse_MoveItemGuildStruct[] =
{
	{ "MoveItemGuildStruct", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MoveItemGuildStruct), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "SrcGuild",				TOK_AUTOINT(MoveItemGuildStruct, bSrcGuild, 0), NULL },
	{ "SrcSlotIdx",				TOK_AUTOINT(MoveItemGuildStruct, iSrcSlotIdx, 0), NULL },
	{ "uSrcItemID",				TOK_AUTOINT(MoveItemGuildStruct, uSrcItemID, 0), NULL },
	{ "SrcEPValue",				TOK_AUTOINT(MoveItemGuildStruct, iSrcEPValue, 0), NULL },
	{ "SrcCount",				TOK_AUTOINT(MoveItemGuildStruct, iSrcCount, 0), NULL },
	{ "DstGuild",				TOK_AUTOINT(MoveItemGuildStruct, bDstGuild, 0), NULL },
	{ "DstSlotIdx",				TOK_AUTOINT(MoveItemGuildStruct, iDstSlotIdx, 0), NULL },
	{ "uDstItemID",				TOK_AUTOINT(MoveItemGuildStruct, uDstItemID, 0), NULL },
	{ "DstEPValue",				TOK_AUTOINT(MoveItemGuildStruct, iDstEPValue, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MoveItemGuildStruct()
{
	int iSize = sizeof(MoveItemGuildStruct);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MoveItemGuildStruct, iSize, "MoveItemGuildStruct", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Item[];
#define TYPE_parse_Item Item
//Structparser.exe autogenerated ParseTable for struct ItemListEntry
#define TYPE_parse_ItemListEntry ItemListEntry
ParseTable parse_ItemListEntry[] =
{
	{ "ItemListEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemListEntry), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "id",				TOK_AUTOINT(ItemListEntry, id, 0), InvBagIDsEnum },
	{ "Slot",			TOK_AUTOINT(ItemListEntry, iSlot, 0), NULL },
	{ "Item",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(ItemListEntry, pItem, parse_Item) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemListEntry()
{
	int iSize = sizeof(ItemListEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemListEntry, iSize, "ItemListEntry", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct RewardPackItem
#define TYPE_parse_RewardPackItem RewardPackItem
ParseTable parse_RewardPackItem[] =
{
	{ "RewardPackItem", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RewardPackItem), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "ItemName",		TOK_STRING(RewardPackItem, pchItemName, 0), NULL },
	{ "Count",			TOK_AUTOINT(RewardPackItem, iCount, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RewardPackItem()
{
	int iSize = sizeof(RewardPackItem);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RewardPackItem, iSize, "RewardPackItem", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_RewardPackItem[];
#define TYPE_parse_RewardPackItem RewardPackItem
//Structparser.exe autogenerated ParseTable for struct RewardPackLog
#define TYPE_parse_RewardPackLog RewardPackLog
ParseTable parse_RewardPackLog[] =
{
	{ "RewardPackLog", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RewardPackLog), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "EntityName",			TOK_STRING(RewardPackLog, pchEntityName, 0), NULL },
	{ "RewardPackName",		TOK_STRING(RewardPackLog, pchRewardPackName, 0), NULL },
	{ "RewardPackItems",	TOK_STRUCT(RewardPackLog, ppRewardPackItems, parse_RewardPackItem) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_RewardPackLog()
{
	int iSize = sizeof(RewardPackLog);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RewardPackLog, iSize, "RewardPackLog", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
extern ParseTable parse_InventoryBagLite[];
#define TYPE_parse_InventoryBagLite InventoryBagLite
//Structparser.exe autogenerated ParseTable for struct BagIterator
#define TYPE_parse_BagIterator BagIterator
ParseTable parse_BagIterator[] =
{
	{ "BagIterator", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(BagIterator), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Bags",			TOK_NO_INDEX | TOK_STRUCT(BagIterator, eaBags, parse_InventoryBag) },
	{ "Litebags",		TOK_NO_INDEX | TOK_STRUCT(BagIterator, eaLitebags, parse_InventoryBagLite) },
	{ "_cur",			TOK_AUTOINT(BagIterator, i_cur, 0), NULL },
	{ "_bag",			TOK_AUTOINT(BagIterator, i_bag, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
extern ThreadSafeMemoryPool tsmemPoolBagIterator;
int autoStruct_fixup_BagIterator()
{
	int iSize = sizeof(BagIterator);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_BagIterator, iSize, "BagIterator", NULL, "inventoryCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesThreadSafeMemPool(parse_BagIterator, &tsmemPoolBagIterator);
	return 0;
};
