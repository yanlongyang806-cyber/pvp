#include "textparser.h"

//auto-generated staticdefine for enum ItemDefFlag
//autogeneratednocheckin
StaticDefineInt ItemDefFlagEnum[] =
{
	DEFINE_INT
	{ "Tradeable", kItemDefFlag_Tradeable},
	{ "BindOnPickup", kItemDefFlag_BindOnPickup},
	{ "BindOnEquip", kItemDefFlag_BindOnEquip},
	{ "EquipOnPickup", kItemDefFlag_EquipOnPickup},
	{ "Enigma", kItemDefFlag_Enigma},
	{ "Fused", kItemDefFlag_Fused},
	{ "CanUseUnequipped", kItemDefFlag_CanUseUnequipped},
	{ "CantSell", kItemDefFlag_CantSell},
	{ "Silent", kItemDefFlag_Silent},
	{ "Unique", kItemDefFlag_Unique},
	{ "LevelFromQuality", kItemDefFlag_LevelFromQuality},
	{ "LevelFromSource", kItemDefFlag_LevelFromSource},
	{ "ScaleWhenBought", kItemDefFlag_ScaleWhenBought},
	{ "RandomAlgoQuality", kItemDefFlag_RandomAlgoQuality},
	{ "NoMinLevel", kItemDefFlag_NoMinLevel},
	{ "Unidentified", kItemDefFlag_Unidentified_Unsafe},
	{ "TransFailonLowLimit", kItemDefFlag_TransFailonLowLimit},
	{ "TransFailonHighLimit", kItemDefFlag_TransFailonHighLimit},
	{ "ExpireOnAnyPower", kItemDefFlag_ExpireOnAnyPower},
	{ "DoorKey", kItemDefFlag_DoorKey},
	{ "SetMissionOnCreate", kItemDefFlag_SetMissionOnCreate},
	{ "ScaleWithCritterScaling", kItemDefFlag_ScaleWithCritterScaling},
	{ "CantDiscard", kItemDefFlag_CantDiscard},
	{ "DoppelgangerPet", kItemDefFlag_DoppelgangerPet},
	{ "CostumeHideable", kItemDefFlag_CostumeHideable},
	{ "UniqueEquipOnePerBag", kItemDefFlag_UniqueEquipOnePerBag},
	{ "LockToRestrictBags", kItemDefFlag_LockToRestrictBags},
	{ "CanSlotOnAssignment", kItemDefFlag_CanSlotOnAssignment},
	{ "BindToAccountOnPickup", kItemDefFlag_BindToAccountOnPickup},
	{ "BindToAccountOnEquip", kItemDefFlag_BindToAccountOnEquip},
	{ "SCPBonusNumeric", kItemDefFlag_SCPBonusNumeric},
	DEFINE_END
};
void autoEnum_fixup_ItemDefFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemDefFlagEnum, "ItemDefFlag");
}

//auto-generated staticdefine for enum ItemPowerFlag
//autogeneratednocheckin
StaticDefineInt ItemPowerFlagEnum[] =
{
	DEFINE_INT
	{ "Gadget", kItemPowerFlag_Gadget},
	{ "CanUseUnequipped", kItemPowerFlag_CanUseUnequipped},
	{ "Rechargeable", kItemPowerFlag_Rechargeable},
	{ "LocalEnhancement", kItemPowerFlag_LocalEnhancement},
	{ "DefaultStance", kItemPowerFlag_DefaultStance},
	DEFINE_END
};
void autoEnum_fixup_ItemPowerFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemPowerFlagEnum, "ItemPowerFlag");
}

//auto-generated staticdefine for enum ItemPowerCategory
//autogeneratednocheckin
extern DefineContext *g_pDefineItemPowerCategories;
StaticDefineInt ItemPowerCategoryEnum[] =
{
	DEFINE_INT
	{ "PowerFactor", kItemPowerCategory_PowerFactor},
	DEFINE_EMBEDDYNAMIC_INT(g_pDefineItemPowerCategories)
	DEFINE_END
};
void autoEnum_fixup_ItemPowerCategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemPowerCategoryEnum, "ItemPowerCategory");
}

//auto-generated staticdefine for enum ItemPowerArtCategory
//autogeneratednocheckin
extern DefineContext *g_pDefineItemPowerArtCategories;
StaticDefineInt ItemPowerArtCategoryEnum[] =
{
	DEFINE_INT
	{ "None", kItemPowerArtCategory_NONE},
	DEFINE_EMBEDDYNAMIC_INT(g_pDefineItemPowerArtCategories)
	DEFINE_END
};
void autoEnum_fixup_ItemPowerArtCategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemPowerArtCategoryEnum, "ItemPowerArtCategory");
}

//auto-generated staticdefine for enum ItemIDType
//autogeneratednocheckin
StaticDefineInt ItemIDTypeEnum[] =
{
	DEFINE_INT
	{ "Player", kItemIDType_Player},
	{ "SavedPet", kItemIDType_SavedPet},
	{ "Puppet", kItemIDType_Puppet},
	{ "Critter", kItemIDType_Critter},
	{ "SharedBank", kItemIDType_SharedBank},
	DEFINE_END
};
void autoEnum_fixup_ItemIDType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemIDTypeEnum, "ItemIDType");
}

//auto-generated staticdefine for enum ItemType
//autogeneratednocheckin
StaticDefineInt ItemTypeEnum[] =
{
	DEFINE_INT
	{ "Upgrade", kItemType_Upgrade},
	{ "Component", kItemType_Component},
	{ "ItemRecipe", kItemType_ItemRecipe},
	{ "Recipe", kItemType_ItemRecipe},
	{ "ItemValue", kItemType_ItemValue},
	{ "ValueRecipe", kItemType_ItemValue},
	{ "ItemPowerRecipe", kItemType_ItemPowerRecipe},
	{ "Mission", kItemType_Mission},
	{ "MissionGrant", kItemType_MissionGrant},
	{ "Boost", kItemType_Boost},
	{ "Device", kItemType_Device},
	{ "Numeric", kItemType_Numeric},
	{ "Weapon", kItemType_Weapon},
	{ "Bag", kItemType_Bag},
	{ "Callout", kItemType_Callout},
	{ "Lore", kItemType_Lore},
	{ "Token", kItemType_Token},
	{ "Title", kItemType_Title},
	{ "SavedPet", kItemType_SavedPet},
	{ "STOBridgeOfficer", kItemType_STOBridgeOfficer},
	{ "AlgoPet", kItemType_AlgoPet},
	{ "TradeGood", kItemType_TradeGood},
	{ "ModifyAttribute", kItemType_ModifyAttribute},
	{ "VanityPet", kItemType_VanityPet},
	{ "Container", kItemType_Container},
	{ "CostumeUnlock", kItemType_CostumeUnlock},
	{ "Injury", kItemType_Injury},
	{ "InjuryCureGround", kItemType_InjuryCureGround},
	{ "InjuryCureSpace", kItemType_InjuryCureSpace},
	{ "RewardPack", kItemType_RewardPack},
	{ "GrantMicroSpecial", kItemType_GrantMicroSpecial},
	{ "ExperienceGift", kItemType_ExperienceGift},
	{ "Coupon", kItemType_Coupon},
	{ "Gem", kItemType_Gem},
	{ "DyeBottle", kItemType_DyeBottle},
	{ "DyePack", kItemType_DyePack},
	{ "UpgradeModifier", kItemType_UpgradeModifier},
	{ "SuperCritterPet", kItemType_SuperCritterPet},
	{ "IdentifyScroll", kItemType_IdentifyScroll},
	{ "LockboxKey", kItemType_LockboxKey},
	{ "PowerFactorLevelUp", kItemType_PowerFactorLevelUp},
	{ "UnidentifiedWrapper", kItemType_UnidentifiedWrapper},
	{ "Junk", kItemType_Junk},
	{ "ProgressionFood", kItemType_ProgressionFood},
	{ "Generic", kItemType_Generic},
	{ "None", kItemType_None},
	DEFINE_END
};
void autoEnum_fixup_ItemType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemTypeEnum, "ItemType");
}

//auto-generated staticdefine for enum SlotType
//autogeneratednocheckin
StaticDefineInt SlotTypeEnum[] =
{
	DEFINE_INT
	{ "Any", kSlotType_Any},
	{ "Primary", kSlotType_Primary},
	{ "Secondary", kSlotType_Secondary},
	DEFINE_END
};
void autoEnum_fixup_SlotType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(SlotTypeEnum, "SlotType");
}

//auto-generated staticdefine for enum ItemFlag
//autogeneratednocheckin
StaticDefineInt ItemFlagEnum[] =
{
	DEFINE_INT
	{ "Bound", kItemFlag_Bound},
	{ "Unidentified", kItemFlag_Unidentified_Unsafe},
	{ "Full", kItemFlag_Full},
	{ "BoundToAccount", kItemFlag_BoundToAccount},
	{ "TrainingFromItem", kItemFlag_TrainingFromItem},
	{ "SlottedOnAssignment", kItemFlag_SlottedOnAssignment},
	{ "Algo", kItemFlag_Algo},
	DEFINE_END
};
void autoEnum_fixup_ItemFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemFlagEnum, "ItemFlag");
}

//auto-generated staticdefine for enum TradeErrorType
//autogeneratednocheckin
StaticDefineInt TradeErrorTypeEnum[] =
{
	DEFINE_INT
	{ "None", kTradeErrorType_None},
	{ "InvalidNumeric", kTradeErrorType_InvalidNumeric},
	{ "ItemBound", kTradeErrorType_ItemBound},
	{ "InvalidItem", kTradeErrorType_InvalidItem},
	{ "CraftingItemInUse", kTradeErrorType_CraftingItemInUse},
	DEFINE_END
};
void autoEnum_fixup_TradeErrorType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(TradeErrorTypeEnum, "TradeErrorType");
}

//auto-generated staticdefine for enum ItemPowerGroup
//autogeneratednocheckin
StaticDefineInt ItemPowerGroupEnum[] =
{
	DEFINE_INT
	{ "Group1", kItemPowerGroup_1},
	{ "Group2", kItemPowerGroup_2},
	{ "Group3", kItemPowerGroup_3},
	{ "Group4", kItemPowerGroup_4},
	{ "Group5", kItemPowerGroup_5},
	{ "Group6", kItemPowerGroup_6},
	{ "Group7", kItemPowerGroup_7},
	{ "Group8", kItemPowerGroup_8},
	DEFINE_END
};
void autoEnum_fixup_ItemPowerGroup(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemPowerGroupEnum, "ItemPowerGroup");
}

//auto-generated staticdefine for enum ComponentCountType
//autogeneratednocheckin
StaticDefineInt ComponentCountTypeEnum[] =
{
	DEFINE_INT
	{ "Fixed", kComponentCountType_Fixed},
	{ "LevelAdjust", kComponentCountType_LevelAdjust},
	{ "Common1", kComponentCountType_Common1},
	{ "Common2", kComponentCountType_Common2},
	{ "UnCommon1", kComponentCountType_UnCommon1},
	{ "UnCommon2", kComponentCountType_UnCommon2},
	{ "Rare1", kComponentCountType_Rare1},
	DEFINE_END
};
void autoEnum_fixup_ComponentCountType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ComponentCountTypeEnum, "ComponentCountType");
}

//auto-generated staticdefine for enum LoreJournalType
//autogeneratednocheckin
extern DefineContext *g_pDefineLoreJournalTypes;
StaticDefineInt LoreJournalTypeEnum[] =
{
	DEFINE_INT
	{ "None", kLoreJournalType_None},
	DEFINE_EMBEDDYNAMIC_INT(g_pDefineLoreJournalTypes)
	DEFINE_END
};
void autoEnum_fixup_LoreJournalType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(LoreJournalTypeEnum, "LoreJournalType");
}

//auto-generated staticdefine for enum ItemBuyBackStatus
//autogeneratednocheckin
StaticDefineInt ItemBuyBackStatusEnum[] =
{
	DEFINE_INT
	{ "None", kItemBuyBackStatus_None},
	{ "Waiting", kItemBuyBackStatus_Waiting},
	{ "OK", kItemBuyBackStatus_OK},
	{ "BeingBought", kItemBuyBackStatus_BeingBought},
	{ "Destroy", kItemBuyBackStatus_Destroy},
	DEFINE_END
};
void autoEnum_fixup_ItemBuyBackStatus(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemBuyBackStatusEnum, "ItemBuyBackStatus");
}

//auto-generated staticdefine for enum SuperCritterPetFlags
//autogeneratednocheckin
StaticDefineInt SuperCritterPetFlagsEnum[] =
{
	DEFINE_INT
	{ "None", kSuperCritterPetFlag_None},
	{ "Dead", kSuperCritterPetFlag_Dead},
	{ "MAX", kSuperCritterPetFlag_MAX},
	DEFINE_END
};
void autoEnum_fixup_SuperCritterPetFlags(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(SuperCritterPetFlagsEnum, "SuperCritterPetFlags");
}

//auto-generated staticdefine for enum ItemQualityFlag
//autogeneratednocheckin
StaticDefineInt ItemQualityFlagEnum[] =
{
	DEFINE_INT
	{ "HideFromUILists", kItemQualityFlag_HideFromUILists},
	{ "ReportToSocialNetworks", kItemQualityFlag_ReportToSocialNetworks},
	{ "IgnoreLootThreshold", kItemQualityFlag_IgnoreLootThreshold},
	DEFINE_END
};
void autoEnum_fixup_ItemQualityFlag(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemQualityFlagEnum, "ItemQualityFlag");
}

//auto-generated staticdefine for enum UsageRestrictionCategory
//autogeneratednocheckin
extern DefineContext *g_pUsageRestrictionCategories;
StaticDefineInt UsageRestrictionCategoryEnum[] =
{
	DEFINE_INT
	{ "None", UsageRestrictionCategory_None},
	DEFINE_EMBEDDYNAMIC_INT(g_pUsageRestrictionCategories)
	DEFINE_END
};
void autoEnum_fixup_UsageRestrictionCategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(UsageRestrictionCategoryEnum, "UsageRestrictionCategory");
}

//auto-generated staticdefine for enum ItemEquipLimitCategory
//autogeneratednocheckin
extern DefineContext *g_pItemEquipLimitCategories;
StaticDefineInt ItemEquipLimitCategoryEnum[] =
{
	DEFINE_INT
	{ "None", kItemEquipLimitCategory_None},
	DEFINE_EMBEDDYNAMIC_INT(g_pItemEquipLimitCategories)
	DEFINE_END
};
void autoEnum_fixup_ItemEquipLimitCategory(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemEquipLimitCategoryEnum, "ItemEquipLimitCategory");
}

//auto-generated staticdefine for enum AdditionalCostumeBoneType
//autogeneratednocheckin
StaticDefineInt AdditionalCostumeBoneTypeEnum[] =
{
	DEFINE_INT
	{ "Clone", kAdditionalCostumeBoneType_Clone},
	{ "Move", kAdditionalCostumeBoneType_Move},
	DEFINE_END
};
void autoEnum_fixup_AdditionalCostumeBoneType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(AdditionalCostumeBoneTypeEnum, "AdditionalCostumeBoneType");
}

//auto-generated staticdefine for enum ItemWarpType
//autogeneratednocheckin
StaticDefineInt ItemWarpTypeEnum[] =
{
	DEFINE_INT
	{ "None", kItemWarp_None},
	{ "SelfToMapSpawn", kItemWarp_SelfToMapSpawn},
	{ "SelfToTarget", kItemWarp_SelfToTarget},
	{ "TeamToSelf", kItemWarp_TeamToSelf},
	{ "TeamToMapSpawn", kItemWarp_TeamToMapSpawn},
	DEFINE_END
};
void autoEnum_fixup_ItemWarpType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemWarpTypeEnum, "ItemWarpType");
}

//auto-generated staticdefine for enum ItemGemType
//autogeneratednocheckin
extern DefineContext *g_pDefineItemGemTypes;
StaticDefineInt ItemGemTypeEnum[] =
{
	DEFINE_INT
	{ "None", kItemGemType_None},
	{ "Any", kItemGemType_Any},
	DEFINE_EMBEDDYNAMIC_INT(g_pDefineItemGemTypes)
	DEFINE_END
};
void autoEnum_fixup_ItemGemType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemGemTypeEnum, "ItemGemType");
}

//auto-generated staticdefine for enum ItemRewardPackType
//autogeneratednocheckin
StaticDefineInt ItemRewardPackTypeEnum[] =
{
	DEFINE_INT
	{ "RewardPack", kItemRewardPackType_RewardPack},
	{ "SalvagedItem", kItemRewardPackType_SalvagedItem},
	{ "Undefined", kItemRewardPackType_Undefined},
	DEFINE_END
};
void autoEnum_fixup_ItemRewardPackType(void)
{
	static bool bOnce = false; if (bOnce) return; bOnce = true;
	RegisterNamedStaticDefine(ItemRewardPackTypeEnum, "ItemRewardPackType");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemIDContainer
#define TYPE_parse_ItemIDContainer ItemIDContainer
ParseTable parse_ItemIDContainer[] =
{
	{ "ItemIDContainer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemIDContainer), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "uiID",				TOK_AUTOINT(ItemIDContainer, uiID, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemIDContainer()
{
	int iSize = sizeof(ItemIDContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemIDContainer, iSize, "ItemIDContainer", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemIDContainer[];
#define TYPE_parse_ItemIDContainer ItemIDContainer
//Structparser.exe autogenerated ParseTable for struct ItemIDList
#define TYPE_parse_ItemIDList ItemIDList
ParseTable parse_ItemIDList[] =
{
	{ "ItemIDList", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemIDList), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "IDs",		TOK_STRUCT(ItemIDList, ppIDs, parse_ItemIDContainer) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemIDList()
{
	int iSize = sizeof(ItemIDList);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemIDList, iSize, "ItemIDList", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct SuperCritterPet
#define TYPE_parse_SuperCritterPet SuperCritterPet
ParseTable parse_SuperCritterPet[] =
{
	{ "SuperCritterPet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SuperCritterPet), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "SuperCritterPetDef",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(SuperCritterPet, hPetDef, 0, "SuperCritterPetDef") },
	{ "hPetDef",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(SuperCritterPet, hPetDef, 0, "SuperCritterPetDef") },
	{ "ClassDef",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(SuperCritterPet, hClassDef, 0, "CharacterClass") },
	{ "hClassDef",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(SuperCritterPet, hClassDef, 0, "CharacterClass") },
	{ "pchName",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRING(SuperCritterPet, pchName, 0), NULL },
	{ "uXP",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(SuperCritterPet, uXP, 0), NULL },
	{ "uLevel",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(SuperCritterPet, uLevel, 0), NULL },
	{ "iCurrentSkin",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(SuperCritterPet, iCurrentSkin, -1), NULL },
	{ "bfFlags",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_AUTOINT(SuperCritterPet, bfFlags, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SuperCritterPet()
{
	int iSize = sizeof(SuperCritterPet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SuperCritterPet, iSize, "SuperCritterPet", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemTransmutationProps
#define TYPE_parse_ItemTransmutationProps ItemTransmutationProps
ParseTable parse_ItemTransmutationProps[] =
{
	{ "ItemTransmutationProps", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemTransmutationProps), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "TransmutatedItemDef",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemTransmutationProps, hTransmutatedItemDef, 0, "ItemDef") },
	{ "hTransmutatedItemDef",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemTransmutationProps, hTransmutatedItemDef, 0, "ItemDef") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemTransmutationProps()
{
	int iSize = sizeof(ItemTransmutationProps);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemTransmutationProps, iSize, "ItemTransmutationProps", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemPowerCategoryNames
#define TYPE_parse_ItemPowerCategoryNames ItemPowerCategoryNames
ParseTable parse_ItemPowerCategoryNames[] =
{
	{ "ItemPowerCategoryNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemPowerCategoryNames), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ItemPowerCategory",		TOK_STRINGARRAY(ItemPowerCategoryNames, ppchNames), NULL },
	{ "ItemPowerArtCategory",	TOK_STRINGARRAY(ItemPowerCategoryNames, ppchArtNames), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemPowerCategoryNames()
{
	int iSize = sizeof(ItemPowerCategoryNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemPowerCategoryNames, iSize, "ItemPowerCategoryNames", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LorePage
#define TYPE_parse_LorePage LorePage
ParseTable parse_LorePage[] =
{
	{ "LorePage", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LorePage), 0, NULL, 0, NULL },
	{ "hItemDef",		TOK_STRUCTPARAM | TOK_REFERENCE(LorePage, hItemDef, 0, "ItemDef") },
	{ "UnlockValue",	TOK_STRUCTPARAM | TOK_AUTOINT(LorePage, iUnlockValue, 0), NULL },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LorePage()
{
	int iSize = sizeof(LorePage);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LorePage, iSize, "LorePage", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LorePage[];
#define TYPE_parse_LorePage LorePage
//Structparser.exe autogenerated ParseTable for struct LoreCategory
#define TYPE_parse_LoreCategory LoreCategory
ParseTable parse_LoreCategory[] =
{
	{ "LoreCategory", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LoreCategory), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(LoreCategory, pchName, 0), NULL },
	{ "ParentCategory",	TOK_POOL_STRING | TOK_STRING(LoreCategory, pchParentCategoryName, 0), NULL },
	{ "PlayerStat",		TOK_REFERENCE(LoreCategory, hPlayerStatDef, 0, "PlayerStatDef") },
	{ "Page",			TOK_STRUCT(LoreCategory, ppPages, parse_LorePage) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LoreCategory()
{
	int iSize = sizeof(LoreCategory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LoreCategory, iSize, "LoreCategory", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_LoreCategory[];
#define TYPE_parse_LoreCategory LoreCategory
//Structparser.exe autogenerated ParseTable for struct LoreCategories
#define TYPE_parse_LoreCategories LoreCategories
ParseTable parse_LoreCategories[] =
{
	{ "LoreCategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LoreCategories), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "LoreCategory",	TOK_STRUCT(LoreCategories, ppCategories, parse_LoreCategory) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LoreCategories()
{
	int iSize = sizeof(LoreCategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LoreCategories, iSize, "LoreCategories", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemQualityInfo
#define TYPE_parse_ItemQualityInfo ItemQualityInfo
ParseTable parse_ItemQualityInfo[] =
{
	{ "ItemQualityInfo", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemQualityInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ItemQualityInfo, pchName, 0), NULL },
	{ "NeedBeforeGreedDelay",	TOK_AUTOINT(ItemQualityInfo, iNeedBeforeGreedDelay, 60), NULL },
	{ "flags",					TOK_AUTOINT(ItemQualityInfo, flags, 0), ItemQualityFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "WeaponDamageMultiplier",	TOK_F32(ItemQualityInfo, fWeaponDamageMultiplier, 1), NULL },
	{ "LootFX",					TOK_POOL_STRING | TOK_STRING(ItemQualityInfo, pchLootFX, 0), NULL },
	{ "RolloverLootFX",			TOK_POOL_STRING | TOK_STRING(ItemQualityInfo, pchRolloverLootFX, 0), NULL },
	{ "ChatLinkColorName",		TOK_STRING(ItemQualityInfo, pchChatLinkColorName, 0), NULL },
	{ "ItemEPValue",			TOK_OPTIONALLATEBINDSTRUCT(ItemQualityInfo, pExprEPValue) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemQualityInfo()
{
	int iSize = sizeof(ItemQualityInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemQualityInfo, iSize, "ItemQualityInfo", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_ItemQualityInfo[5].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemQualityInfo(void)
{
	DoAutoStructLateBind(parse_ItemQualityInfo, 9, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_ItemQualityInfo[];
#define TYPE_parse_ItemQualityInfo ItemQualityInfo
//Structparser.exe autogenerated ParseTable for struct ItemQualities
#define TYPE_parse_ItemQualities ItemQualities
ParseTable parse_ItemQualities[] =
{
	{ "ItemQualities", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemQualities), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "ItemQuality",	TOK_STRUCT(ItemQualities, ppQualities, parse_ItemQualityInfo) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemQualities()
{
	int iSize = sizeof(ItemQualities);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemQualities, iSize, "ItemQualities", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemVar
#define TYPE_parse_ItemVar ItemVar
ParseTable parse_ItemVar[] =
{
	{ "ItemVar", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemVar), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Name",		TOK_STRUCTPARAM | TOK_STRING(ItemVar, pchName, 0), NULL },
	{ "Value",		TOK_MULTIVAL(ItemVar, mvValue), NULL},
	{ "hVarHandle",	TOK_AUTOINT(ItemVar, hVarHandle, 0), NULL },
	{ "File",		TOK_POOL_STRING | TOK_CURRENTFILE(ItemVar, cpchFile), NULL},
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemVar()
{
	int iSize = sizeof(ItemVar);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemVar, iSize, "ItemVar", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemVar[];
#define TYPE_parse_ItemVar ItemVar
//Structparser.exe autogenerated ParseTable for struct ItemVars
#define TYPE_parse_ItemVars ItemVars
ParseTable parse_ItemVars[] =
{
	{ "ItemVars", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemVars), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "ItemVar",	TOK_STRUCT(ItemVars, ppItemVars, parse_ItemVar) },
	{ "stItemVars",	TOK_NO_WRITE | TOK_STASHTABLE(ItemVars, stItemVars), NULL},
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemVars()
{
	int iSize = sizeof(ItemVars);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemVars, iSize, "ItemVars", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct UsageRestrictionCategories
#define TYPE_parse_UsageRestrictionCategories UsageRestrictionCategories
ParseTable parse_UsageRestrictionCategories[] =
{
	{ "UsageRestrictionCategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UsageRestrictionCategories), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "UICategoryName",				TOK_STRINGARRAY(UsageRestrictionCategories, pchNames), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_UsageRestrictionCategories()
{
	int iSize = sizeof(UsageRestrictionCategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UsageRestrictionCategories, iSize, "UsageRestrictionCategories", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AllegianceRef[];
#define TYPE_parse_AllegianceRef AllegianceRef
extern ParseTable parse_CharacterClassRef[];
#define TYPE_parse_CharacterClassRef CharacterClassRef
extern ParseTable parse_CharacterPathRef[];
#define TYPE_parse_CharacterPathRef CharacterPathRef
//Structparser.exe autogenerated ParseTable for struct UsageRestriction
#define TYPE_parse_UsageRestriction UsageRestriction
ParseTable parse_UsageRestriction[] =
{
	{ "UsageRestriction", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(UsageRestriction), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "MinLevel",				TOK_AUTOINT(UsageRestriction, iMinLevel, 0), NULL },
	{ "MaxLevel",				TOK_AUTOINT(UsageRestriction, iMaxLevel, 0), NULL },
	{ "SkillType",				TOK_AUTOINT(UsageRestriction, eSkillType, 0), SkillTypeEnum },
	{ "SkillLevel",				TOK_AUTOINT(UsageRestriction, iSkillLevel, 0), NULL },
	{ "pRequiresBlock",			TOK_USEROPTIONBIT_1 | TOK_OPTIONALLATEBINDSTRUCT(UsageRestriction, pRequires) },
	{ "pRequires",				TOK_REDUNDANTNAME | TOK_USEROPTIONBIT_1 | TOK_OPTIONALLATEBINDSTRUCT(UsageRestriction, pRequires) },
	{ "UICategory",				TOK_AUTOINT(UsageRestriction, eUICategory, UsageRestrictionCategory_None), UsageRestrictionCategoryEnum },
	{ "RequiredAllegiance",		TOK_STRUCT(UsageRestriction, eaRequiredAllegiances, parse_AllegianceRef) },
	{ "RequireAllAllegiances",	TOK_AUTOINT(UsageRestriction, bRequireAllAllegiances, 0), NULL },
	{ "ClassAllowed",			TOK_STRUCT(UsageRestriction, ppCharacterClassesAllowed, parse_CharacterClassRef) },
	{ "ClassCategoryAllowed",	TOK_INTARRAY(UsageRestriction, peClassCategoriesAllowed),  CharClassCategoryEnum},
	{ "PathAllowed",			TOK_STRUCT(UsageRestriction, ppCharacterPathsAllowed, parse_CharacterPathRef) },
	{ "RequiredGemSlotType",	TOK_AUTOINT(UsageRestriction, eRequiredGemSlotType, 0), ItemGemTypeEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolUsageRestriction;
int autoStruct_fixup_UsageRestriction()
{
	int iSize = sizeof(UsageRestriction);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_UsageRestriction, iSize, "UsageRestriction", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_UsageRestriction, &memPoolUsageRestriction);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_UsageRestriction(void)
{
	DoAutoStructLateBind(parse_UsageRestriction, 6, "Expression");
	DoAutoStructLateBind(parse_UsageRestriction, 7, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct ItemEquipLimitCategoryData
#define TYPE_parse_ItemEquipLimitCategoryData ItemEquipLimitCategoryData
ParseTable parse_ItemEquipLimitCategoryData[] =
{
	{ "ItemEquipLimitCategoryData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemEquipLimitCategoryData), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Name",						TOK_STRUCTPARAM | TOK_STRING(ItemEquipLimitCategoryData, pchName, 0), NULL },
	{ "DisplayName",				TOK_EMBEDDEDSTRUCT(ItemEquipLimitCategoryData, msgDisplayName, parse_DisplayMessage)},
	{ "MaxItemCount",				TOK_AUTOINT(ItemEquipLimitCategoryData, iMaxItemCount, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemEquipLimitCategoryData()
{
	int iSize = sizeof(ItemEquipLimitCategoryData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemEquipLimitCategoryData, iSize, "ItemEquipLimitCategoryData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemEquipLimitCategoryData[];
#define TYPE_parse_ItemEquipLimitCategoryData ItemEquipLimitCategoryData
//Structparser.exe autogenerated ParseTable for struct ItemEquipLimitCategories
#define TYPE_parse_ItemEquipLimitCategories ItemEquipLimitCategories
ParseTable parse_ItemEquipLimitCategories[] =
{
	{ "ItemEquipLimitCategories", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemEquipLimitCategories), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "Category",					TOK_STRUCT(ItemEquipLimitCategories, eaData, parse_ItemEquipLimitCategoryData) },
	{ "CategoryName",				TOK_REDUNDANTNAME | TOK_STRUCT(ItemEquipLimitCategories, eaData, parse_ItemEquipLimitCategoryData) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemEquipLimitCategories()
{
	int iSize = sizeof(ItemEquipLimitCategories);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemEquipLimitCategories, iSize, "ItemEquipLimitCategories", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemEquipLimit
#define TYPE_parse_ItemEquipLimit ItemEquipLimit
ParseTable parse_ItemEquipLimit[] =
{
	{ "ItemEquipLimit", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemEquipLimit), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "MaxEquipCount",	TOK_AUTOINT(ItemEquipLimit, iMaxEquipCount, 0), NULL },
	{ "Category",		TOK_AUTOINT(ItemEquipLimit, eCategory, 0), ItemEquipLimitCategoryEnum },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemEquipLimit()
{
	int iSize = sizeof(ItemEquipLimit);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemEquipLimit, iSize, "ItemEquipLimit", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemCraftingComponent
#define TYPE_parse_ItemCraftingComponent ItemCraftingComponent
ParseTable parse_ItemCraftingComponent[] =
{
	{ "ItemCraftingComponent", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCraftingComponent), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Item",					TOK_STRUCTPARAM | TOK_REQUIRED | TOK_REFERENCE(ItemCraftingComponent, hItem, 0, "ItemDef") },
	{ "Count",					TOK_STRUCTPARAM | TOK_F32(ItemCraftingComponent, fCount, 1), NULL },
	{ "Weight",					TOK_F32(ItemCraftingComponent, fWeight, 1), NULL },
	{ "MinLevel",				TOK_AUTOINT(ItemCraftingComponent, iMinLevel, 1), NULL },
	{ "MaxLevel",				TOK_AUTOINT(ItemCraftingComponent, iMaxLevel, 50), NULL },
	{ "DeconstructOnly",		TOK_AUTOINT(ItemCraftingComponent, bDeconstructOnly, 0), NULL },
	{ "CountType",				TOK_AUTOINT(ItemCraftingComponent, CountType, 0), ComponentCountTypeEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCraftingComponent()
{
	int iSize = sizeof(ItemCraftingComponent);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCraftingComponent, iSize, "ItemCraftingComponent", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_ItemCraftingComponent[3].param = GET_INTPTR_FROM_FLOAT((float)1);
	parse_ItemCraftingComponent[4].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemCraftingComponent[];
#define TYPE_parse_ItemCraftingComponent ItemCraftingComponent
//Structparser.exe autogenerated ParseTable for struct ItemCraftingTable
#define TYPE_parse_ItemCraftingTable ItemCraftingTable
ParseTable parse_ItemCraftingTable[] =
{
	{ "ItemCraftingTable", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCraftingTable), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Resource",			TOK_AUTOINT(ItemCraftingTable, iResource, 0), NULL },
	{ "ResultCount",		TOK_AUTOINT(ItemCraftingTable, iResultCount, 1), NULL },
	{ "ItemResult",			TOK_REFERENCE(ItemCraftingTable, hItemResult, 0, "ItemDef") },
	{ "Result",				TOK_REDUNDANTNAME | TOK_REFERENCE(ItemCraftingTable, hItemResult, 0, "ItemDef") },
	{ "ItemPowerResult",	TOK_REFERENCE(ItemCraftingTable, hItemPowerResult, 0, "ItemPowerDef") },
	{ "Part",				TOK_STRUCT(ItemCraftingTable, ppPart, parse_ItemCraftingComponent) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCraftingTable()
{
	int iSize = sizeof(ItemCraftingTable);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCraftingTable, iSize, "ItemCraftingTable", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct LoreJournalData
#define TYPE_parse_LoreJournalData LoreJournalData
ParseTable parse_LoreJournalData[] =
{
	{ "LoreJournalData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(LoreJournalData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Type",				TOK_AUTOINT(LoreJournalData, eType, 0), LoreJournalTypeEnum },
	{ "Textures",			TOK_POOL_STRING | TOK_STRINGARRAY(LoreJournalData, ppchTextures), NULL },
	{ "CritterName",		TOK_POOL_STRING | TOK_STRING(LoreJournalData, pchCritterName, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_LoreJournalData()
{
	int iSize = sizeof(LoreJournalData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_LoreJournalData, iSize, "LoreJournalData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_UsageRestriction[];
#define TYPE_parse_UsageRestriction UsageRestriction
extern ParseTable parse_CritterPowerConfig[];
#define TYPE_parse_CritterPowerConfig CritterPowerConfig
//Structparser.exe autogenerated ParseTable for struct ItemPowerDef
#define TYPE_parse_ItemPowerDef ItemPowerDef
ParseTable parse_ItemPowerDef[] =
{
	{ "ItemPowerDef", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemPowerDef), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Name",				TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(ItemPowerDef, pchName, 0), NULL },
	{ "FileName",			TOK_POOL_STRING | TOK_CURRENTFILE(ItemPowerDef, pchFileName), NULL},
	{ "Scope",				TOK_POOL_STRING | TOK_STRING(ItemPowerDef, pchScope, 0), NULL },
	{ "displayNameMsg",		TOK_EMBEDDEDSTRUCT(ItemPowerDef, displayNameMsg, parse_DisplayMessage)},
	{ "displayNameMsg2",	TOK_EMBEDDEDSTRUCT(ItemPowerDef, displayNameMsg2, parse_DisplayMessage)},
	{ "descriptionMsg",		TOK_EMBEDDEDSTRUCT(ItemPowerDef, descriptionMsg, parse_DisplayMessage)},
	{ "Icon",				TOK_POOL_STRING | TOK_STRING(ItemPowerDef, pchIconName, 0), NULL },
	{ "Notes",				TOK_STRING(ItemPowerDef, pchNotes, 0), NULL },
	{ "flags",				TOK_AUTOINT(ItemPowerDef, flags, 0), ItemPowerFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "ExprEconomyPoints",	TOK_OPTIONALLATEBINDSTRUCT(ItemPowerDef, pExprEconomyPoints) },
	{ "Power",				TOK_REFERENCE(ItemPowerDef, hPower, 0, "PowerDef") },
	{ "PowerReplace",		TOK_REFERENCE(ItemPowerDef, hPowerReplace, 0, "PowerReplaceDef") },
	{ "PowerSlot",			TOK_REDUNDANTNAME | TOK_REFERENCE(ItemPowerDef, hPowerReplace, 0, "PowerReplaceDef") },
	{ "Restriction",		TOK_OPTIONALSTRUCT(ItemPowerDef, pRestriction, parse_UsageRestriction) },
	{ "CraftRecipe",		TOK_REFERENCE(ItemPowerDef, hCraftRecipe, 0, "ItemDef") },
	{ "ValueRecipe",		TOK_REFERENCE(ItemPowerDef, hValueRecipe, 0, "ItemDef") },
	{ "PowerConfig",		TOK_OPTIONALSTRUCT(ItemPowerDef, pPowerConfig, parse_CritterPowerConfig) },
	{ "PointBuyCost",		TOK_AUTOINT(ItemPowerDef, iPointBuyCost, 0), NULL },
	{ "ItemPowerCategory",	TOK_AUTOINT(ItemPowerDef, eItemPowerCategories, 0), ItemPowerCategoryEnum  ,  TOK_FORMAT_FLAGS},
	{ "ArtCategory",		TOK_AUTOINT(ItemPowerDef, iArtCategory, 0), ItemPowerArtCategoryEnum },
	{ "FactorValue",		TOK_AUTOINT(ItemPowerDef, iFactorValue, 0), NULL },
	{ "Group",				TOK_IGNORE, 0 },
	{ "EconomyPoints",		TOK_IGNORE, 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemPowerDef()
{
	int iSize = sizeof(ItemPowerDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemPowerDef, iSize, "ItemPowerDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemPowerDef(void)
{
	DoAutoStructLateBind(parse_ItemPowerDef, 11, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemPowerDefRef
#define TYPE_parse_ItemPowerDefRef ItemPowerDefRef
ParseTable parse_ItemPowerDefRef[] =
{
	{ "ItemPowerDefRef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemPowerDefRef), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "uID",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemPowerDefRef, uID, 0), NULL },
	{ "ItemPowerDef",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REQUIRED | TOK_REFERENCE(ItemPowerDefRef, hItemPowerDef, 0, "ItemPowerDef") },
	{ "hItemPowerDef",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemPowerDefRef, hItemPowerDef, 0, "ItemPowerDef") },
	{ "ScaleFactor",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_F32(ItemPowerDefRef, ScaleFactor, 1.0f), NULL },
	{ "AppliesToSlot",				TOK_AUTOINT(ItemPowerDefRef, eAppliesToSlot, 0), InvBagIDsEnum },
	{ "eAppliesToSlot",				TOK_REDUNDANTNAME | TOK_AUTOINT(ItemPowerDefRef, eAppliesToSlot, 0), InvBagIDsEnum },
	{ "RequiredCategories",			TOK_INTARRAY(ItemPowerDefRef, peRequiredCategories),  ItemCategoryEnum},
	{ "peRequiredCategories",		TOK_REDUNDANTNAME | TOK_INTARRAY(ItemPowerDefRef, peRequiredCategories),  ItemCategoryEnum},
	{ "ChanceToApply",				TOK_F32(ItemPowerDefRef, fChanceToApply, 0), NULL },
	{ "fChanceToApply",				TOK_REDUNDANTNAME | TOK_F32(ItemPowerDefRef, fChanceToApply, 0), NULL },
	{ "iPowerGroup",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "GemSlottingApplyChance",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_F32(ItemPowerDefRef, fGemSlottingApplyChance, 1.0f), NULL },
	{ "fGemSlottingApplyChance",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_F32(ItemPowerDefRef, fGemSlottingApplyChance, 1.0f), NULL },
	{ "SetMin",						TOK_BIT, 0, 8, NULL},
	{ "uiSetMin",					TOK_REDUNDANTNAME | TOK_BIT, 0, 8, NULL},
	{ "bGemSlotsAdjustScaleFactor",	TOK_BIT, 0, 8, NULL},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
typedef struct MemoryPoolImp *MemoryPool;
extern MemoryPool memPoolItemPowerDefRef;
int autoStruct_fixup_ItemPowerDefRef()
{
	int iSize = sizeof(ItemPowerDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemPowerDefRef, iSize, "ItemPowerDefRef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	ParserSetTPIUsesSingleThreadedMemPool(parse_ItemPowerDefRef, &memPoolItemPowerDefRef);
	{
		int iSizeInWords = (sizeof(NOCONST(ItemPowerDefRef)) + 7) / 4;
		NOCONST(ItemPowerDefRef) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->iPowerGroup = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemPowerDefRef[12]);
		pTemp->iPowerGroup = 0;
		pTemp->uiSetMin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemPowerDefRef[15]);
		pTemp->uiSetMin = 0;
		pTemp->uiSetMin = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemPowerDefRef[16]);
		pTemp->uiSetMin = 0;
		pTemp->bGemSlotsAdjustScaleFactor = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemPowerDefRef[17]);
		pTemp->bGemSlotsAdjustScaleFactor = 0;
	}
	parse_ItemPowerDefRef[5].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	parse_ItemPowerDefRef[13].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	parse_ItemPowerDefRef[14].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemPowerDefRef[];
#define TYPE_parse_ItemPowerDefRef ItemPowerDefRef
//Structparser.exe autogenerated ParseTable for struct InfuseRank
#define TYPE_parse_InfuseRank InfuseRank
ParseTable parse_InfuseRank[] =
{
	{ "InfuseRank", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InfuseRank), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Cost",				TOK_AUTOINT(InfuseRank, iCost, 0), NULL },
	{ "Icon",				TOK_POOL_STRING | TOK_STRING(InfuseRank, pchIcon, 0), NULL },
	{ "ItemPowerDefRef",	TOK_STRUCT(InfuseRank, ppDefRefs, parse_ItemPowerDefRef) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InfuseRank()
{
	int iSize = sizeof(InfuseRank);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InfuseRank, iSize, "InfuseRank", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InfuseRank[];
#define TYPE_parse_InfuseRank InfuseRank
//Structparser.exe autogenerated ParseTable for struct InfuseOption
#define TYPE_parse_InfuseOption InfuseOption
ParseTable parse_InfuseOption[] =
{
	{ "InfuseOption", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InfuseOption), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Item",			TOK_REFERENCE(InfuseOption, hItem, 0, "ItemDef") },
	{ "Rank",			TOK_STRUCT(InfuseOption, ppRanks, parse_InfuseRank) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InfuseOption()
{
	int iSize = sizeof(InfuseOption);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InfuseOption, iSize, "InfuseOption", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InfuseOption[];
#define TYPE_parse_InfuseOption InfuseOption
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct InfuseSlotDef
#define TYPE_parse_InfuseSlotDef InfuseSlotDef
ParseTable parse_InfuseSlotDef[] =
{
	{ "InfuseSlotDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InfuseSlotDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Name",			TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(InfuseSlotDef, pchName, 0), NULL },
	{ "Option",			TOK_STRUCT(InfuseSlotDef, ppOptions, parse_InfuseOption) },
	{ "msgDisplayName",	TOK_EMBEDDEDSTRUCT(InfuseSlotDef, msgDisplayName, parse_DisplayMessage)},
	{ "msgDescription",	TOK_EMBEDDEDSTRUCT(InfuseSlotDef, msgDescription, parse_DisplayMessage)},
	{ "Icon",			TOK_POOL_STRING | TOK_STRING(InfuseSlotDef, pchIcon, 0), NULL },
	{ "FileName",		TOK_POOL_STRING | TOK_CURRENTFILE(InfuseSlotDef, pchFileName), NULL},
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InfuseSlotDef()
{
	int iSize = sizeof(InfuseSlotDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InfuseSlotDef, iSize, "InfuseSlotDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InfuseSlotDefRef
#define TYPE_parse_InfuseSlotDefRef InfuseSlotDefRef
ParseTable parse_InfuseSlotDefRef[] =
{
	{ "InfuseSlotDefRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InfuseSlotDefRef), 0, NULL, 0, NULL },
	{ "hDef",				TOK_STRUCTPARAM | TOK_REFERENCE(InfuseSlotDefRef, hDef, 0, "InfuseSlotDef") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InfuseSlotDefRef()
{
	int iSize = sizeof(InfuseSlotDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InfuseSlotDefRef, iSize, "InfuseSlotDefRef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InfuseSlot
#define TYPE_parse_InfuseSlot InfuseSlot
ParseTable parse_InfuseSlot[] =
{
	{ "InfuseSlot", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InfuseSlot), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "hDef",		TOK_PERSIST | TOK_REFERENCE(InfuseSlot, hDef, 0, "InfuseSlotDef") },
	{ "hItem",		TOK_PERSIST | TOK_REFERENCE(InfuseSlot, hItem, 0, "ItemDef") },
	{ "iRefund",	TOK_PERSIST | TOK_AUTOINT(InfuseSlot, iRefund, 0), NULL },
	{ "iIndex",		TOK_PERSIST | TOK_KEY | TOK_AUTOINT(InfuseSlot, iIndex, 0), NULL },
	{ "iRank",		TOK_PERSIST | TOK_AUTOINT(InfuseSlot, iRank, 0), NULL },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InfuseSlot()
{
	int iSize = sizeof(InfuseSlot);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InfuseSlot, iSize, "InfuseSlot", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemCostume
#define TYPE_parse_ItemCostume ItemCostume
ParseTable parse_ItemCostume[] =
{
	{ "ItemCostume", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCostume), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Costume",			TOK_STRUCTPARAM | TOK_REFERENCE(ItemCostume, hCostumeRef, 0, "PlayerCostume") },
	{ "ExprBlockRequires",	TOK_OPTIONALLATEBINDSTRUCT(ItemCostume, pExprRequires) },
	{ "ExprRequiresBlock",	TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemCostume, pExprRequires) },
	{ "ExprRequires",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemCostume, pExprRequires) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCostume()
{
	int iSize = sizeof(ItemCostume);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCostume, iSize, "ItemCostume", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemCostume(void)
{
	DoAutoStructLateBind(parse_ItemCostume, 3, "Expression");
	DoAutoStructLateBind(parse_ItemCostume, 4, "Expression");
	DoAutoStructLateBind(parse_ItemCostume, 5, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_PlayerCostume[];
#define TYPE_parse_PlayerCostume PlayerCostume
//Structparser.exe autogenerated ParseTable for struct CostumeCloneForItemCat
#define TYPE_parse_CostumeCloneForItemCat CostumeCloneForItemCat
ParseTable parse_CostumeCloneForItemCat[] =
{
	{ "CostumeCloneForItemCat", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CostumeCloneForItemCat), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "CostumeData",			TOK_OPTIONALSTRUCT(CostumeCloneForItemCat, pCostumeData, parse_PlayerCostume) },
	{ "Name",					TOK_POOL_STRING | TOK_KEY | TOK_STRING(CostumeCloneForItemCat, pcName, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CostumeCloneForItemCat()
{
	int iSize = sizeof(CostumeCloneForItemCat);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CostumeCloneForItemCat, iSize, "CostumeCloneForItemCat", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemCostumeClone
#define TYPE_parse_ItemCostumeClone ItemCostumeClone
ParseTable parse_ItemCostumeClone[] =
{
	{ "ItemCostumeClone", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCostumeClone), 0, NULL, 0, NULL },
	{ "Costume",			TOK_STRUCTPARAM | TOK_REFERENCE(ItemCostumeClone, hCostumeRef, 0, "CostumeCloneForItemCat") },
	{ "\n",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCostumeClone()
{
	int iSize = sizeof(ItemCostumeClone);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCostumeClone, iSize, "ItemCostumeClone", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemVanityPet
#define TYPE_parse_ItemVanityPet ItemVanityPet
ParseTable parse_ItemVanityPet[] =
{
	{ "ItemVanityPet", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemVanityPet), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "VanityPet",		TOK_REFERENCE(ItemVanityPet, hPowerDef, 0, "PowerDef") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemVanityPet()
{
	int iSize = sizeof(ItemVanityPet);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemVanityPet, iSize, "ItemVanityPet", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemTagNames
#define TYPE_parse_ItemTagNames ItemTagNames
ParseTable parse_ItemTagNames[] =
{
	{ "ItemTagNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemTagNames), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "ItemTag",		TOK_STRINGARRAY(ItemTagNames, ppchName), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemTagNames()
{
	int iSize = sizeof(ItemTagNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemTagNames, iSize, "ItemTagNames", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemCategoryAdditionalCostumeBone
#define TYPE_parse_ItemCategoryAdditionalCostumeBone ItemCategoryAdditionalCostumeBone
ParseTable parse_ItemCategoryAdditionalCostumeBone[] =
{
	{ "ItemCategoryAdditionalCostumeBone", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCategoryAdditionalCostumeBone), 0, NULL, 0, NULL },
	{ "Type",								TOK_STRUCTPARAM | TOK_AUTOINT(ItemCategoryAdditionalCostumeBone, eType, 0), AdditionalCostumeBoneTypeEnum },
	{ "Old",								TOK_STRUCTPARAM | TOK_REFERENCE(ItemCategoryAdditionalCostumeBone, hOldBone, 0, "PCBoneDef") },
	{ "New",								TOK_STRUCTPARAM | TOK_REFERENCE(ItemCategoryAdditionalCostumeBone, hNewBone, 0, "PCBoneDef") },
	{ "\n",									TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCategoryAdditionalCostumeBone()
{
	int iSize = sizeof(ItemCategoryAdditionalCostumeBone);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCategoryAdditionalCostumeBone, iSize, "ItemCategoryAdditionalCostumeBone", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemCategoryAdditionalCostumeBone[];
#define TYPE_parse_ItemCategoryAdditionalCostumeBone ItemCategoryAdditionalCostumeBone
extern ParseTable parse_ItemCategoryAdditionalCostumeBone[];
#define TYPE_parse_ItemCategoryAdditionalCostumeBone ItemCategoryAdditionalCostumeBone
//Structparser.exe autogenerated ParseTable for struct ItemCategoryInfo
#define TYPE_parse_ItemCategoryInfo ItemCategoryInfo
ParseTable parse_ItemCategoryInfo[] =
{
	{ "ItemCategoryInfo", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCategoryInfo), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "Name",							TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchName, 0), NULL },
	{ "Hint",							TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchHint, 0), NULL },
	{ "Hint2",							TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchHint2, 0), NULL },
	{ "Icon",							TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchIcon, 0), NULL },
	{ "LargeIcon",						TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchLargeIcon, 0), NULL },
	{ "SortOrder",						TOK_AUTOINT(ItemCategoryInfo, iSortOrder, 0), NULL },
	{ "GemSlotPowerPortion",			TOK_F32(ItemCategoryInfo, fGemSlotPowerPortion, 0), NULL },
	{ "StanceWords",					TOK_STRING(ItemCategoryInfo, pchStanceWords, 0), NULL },
	{ "PrimaryAddedBone",				TOK_STRUCT(ItemCategoryInfo, eaPrimarySlotAdditionalBones, parse_ItemCategoryAdditionalCostumeBone) },
	{ "SecondaryAddedBone",				TOK_STRUCT(ItemCategoryInfo, eaSecondarySlotAdditionalBones, parse_ItemCategoryAdditionalCostumeBone) },
	{ "CostumeFXScale",					TOK_F32(ItemCategoryInfo, fCostumeFXScaleValue, 0), NULL },
	{ "OverrideBaseCostumeFXAtBone",	TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchOverrideBaseCostumeFXAtBone, 0), NULL },
	{ "OverrideCostumeFXAtBone",		TOK_POOL_STRING | TOK_STRING(ItemCategoryInfo, pchOverrideCostumeFXBone, 0), NULL },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCategoryInfo()
{
	int iSize = sizeof(ItemCategoryInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCategoryInfo, iSize, "ItemCategoryInfo", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemCategoryInfo[];
#define TYPE_parse_ItemCategoryInfo ItemCategoryInfo
//Structparser.exe autogenerated ParseTable for struct ItemCategoryNames
#define TYPE_parse_ItemCategoryNames ItemCategoryNames
ParseTable parse_ItemCategoryNames[] =
{
	{ "ItemCategoryNames", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemCategoryNames), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "ItemCategory",		TOK_STRUCT(ItemCategoryNames, ppInfo, parse_ItemCategoryInfo) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemCategoryNames()
{
	int iSize = sizeof(ItemCategoryNames);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemCategoryNames, iSize, "ItemCategoryNames", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_TempAttributes[];
#define TYPE_parse_TempAttributes TempAttributes
//Structparser.exe autogenerated ParseTable for struct ItemAttribModifyValues
#define TYPE_parse_ItemAttribModifyValues ItemAttribModifyValues
ParseTable parse_ItemAttribModifyValues[] =
{
	{ "ItemAttribModifyValues", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemAttribModifyValues), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "TempAttribs",			TOK_OPTIONALSTRUCT(ItemAttribModifyValues, pTempAttribs, parse_TempAttributes) },
	{ "SavedPetClassType",		TOK_AUTOINT(ItemAttribModifyValues, eSavedPetClassType, 0), CharClassTypesEnum },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemAttribModifyValues()
{
	int iSize = sizeof(ItemAttribModifyValues);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemAttribModifyValues, iSize, "ItemAttribModifyValues", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDefRef
#define TYPE_parse_ItemDefRef ItemDefRef
ParseTable parse_ItemDefRef[] =
{
	{ "ItemDefRef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDefRef), 0, NULL, 0, NULL },
	{ "hDef",		TOK_STRUCTPARAM | TOK_REFERENCE(ItemDefRef, hDef, 0, "ItemDef") },
	{ "\n",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDefRef()
{
	int iSize = sizeof(ItemDefRef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDefRef, iSize, "ItemDefRef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDefRefCont
#define TYPE_parse_ItemDefRefCont ItemDefRefCont
ParseTable parse_ItemDefRefCont[] =
{
	{ "ItemDefRefCont", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDefRefCont), 0, NULL, 0, NULL },
	{ "hDef",			TOK_STRUCTPARAM | TOK_PERSIST | TOK_REFERENCE(ItemDefRefCont, hDef, 0, "ItemDef") },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDefRefCont()
{
	int iSize = sizeof(ItemDefRefCont);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDefRefCont, iSize, "ItemDefRefCont", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemNumericData
#define TYPE_parse_ItemNumericData ItemNumericData
ParseTable parse_ItemNumericData[] =
{
	{ "ItemNumericData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemNumericData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hDef",				TOK_REFERENCE(ItemNumericData, hDef, 0, "ItemDef") },
	{ "NumericValue",		TOK_AUTOINT(ItemNumericData, iNumericValue, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemNumericData()
{
	int iSize = sizeof(ItemNumericData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemNumericData, iSize, "ItemNumericData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDefWarp
#define TYPE_parse_ItemDefWarp ItemDefWarp
ParseTable parse_ItemDefWarp[] =
{
	{ "ItemDefWarp", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDefWarp), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "LimitedUse",			TOK_AUTOINT(ItemDefWarp, bLimitedUse, 0), NULL },
	{ "WarpChargesMax",		TOK_AUTOINT(ItemDefWarp, iWarpChargesMax_DEPRECATED, 0), NULL },
	{ "Map",				TOK_POOL_STRING | TOK_STRING(ItemDefWarp, pchMap, 0), NULL },
	{ "Spawn",				TOK_POOL_STRING | TOK_STRING(ItemDefWarp, pchSpawn, 0), NULL },
	{ "uiTimeToConfirm",	TOK_AUTOINT(ItemDefWarp, uiTimeToConfirm, 0), NULL },
	{ "WarpType",			TOK_BIT, 0, 8, ItemWarpTypeEnum},
	{ "CanMapMove",			TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ItemDefWarp()
{
	int iSize = sizeof(ItemDefWarp);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDefWarp, iSize, "ItemDefWarp", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(ItemDefWarp) + 7) / 4;
		ItemDefWarp *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->eWarpType = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDefWarp[7]);
		pTemp->eWarpType = 0;
		pTemp->bCanMapMove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDefWarp[8]);
		pTemp->bCanMapMove = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemWeaponDef
#define TYPE_parse_ItemWeaponDef ItemWeaponDef
ParseTable parse_ItemWeaponDef[] =
{
	{ "ItemWeaponDef", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemWeaponDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "DieSize",				TOK_AUTOINT(ItemWeaponDef, iDieSize, 0), NULL },
	{ "NumDice",				TOK_AUTOINT(ItemWeaponDef, iNumDice, 1), NULL },
	{ "AdditionalDamageExpr",	TOK_OPTIONALLATEBINDSTRUCT(ItemWeaponDef, pAdditionalDamageExpr) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemWeaponDef()
{
	int iSize = sizeof(ItemWeaponDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemWeaponDef, iSize, "ItemWeaponDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemWeaponDef(void)
{
	DoAutoStructLateBind(parse_ItemWeaponDef, 4, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDamageDef
#define TYPE_parse_ItemDamageDef ItemDamageDef
ParseTable parse_ItemDamageDef[] =
{
	{ "ItemDamageDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDamageDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "ExprMagnitude",	TOK_OPTIONALLATEBINDSTRUCT(ItemDamageDef, pExprMagnitude) },
	{ "Variance",		TOK_F32(ItemDamageDef, fVariance, 0), NULL },
	{ "TableName",		TOK_POOL_STRING | TOK_STRING(ItemDamageDef, pchTableName, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDamageDef()
{
	int iSize = sizeof(ItemDamageDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDamageDef, iSize, "ItemDamageDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemDamageDef(void)
{
	DoAutoStructLateBind(parse_ItemDamageDef, 2, "Expression");
}
//autogeneratednocheckin
extern ParseTable parse_ItemDefRef[];
#define TYPE_parse_ItemDefRef ItemDefRef
//Structparser.exe autogenerated ParseTable for struct ItemSetMembers
#define TYPE_parse_ItemSetMembers ItemSetMembers
ParseTable parse_ItemSetMembers[] =
{
	{ "ItemSetMembers", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemSetMembers), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Members",		TOK_STRUCT(ItemSetMembers, eaMembers, parse_ItemDefRef) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemSetMembers()
{
	int iSize = sizeof(ItemSetMembers);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemSetMembers, iSize, "ItemSetMembers", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemTrainablePowerNode
#define TYPE_parse_ItemTrainablePowerNode ItemTrainablePowerNode
ParseTable parse_ItemTrainablePowerNode[] =
{
	{ "ItemTrainablePowerNode", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemTrainablePowerNode), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "NodeDef",				TOK_STRUCTPARAM | TOK_REFERENCE(ItemTrainablePowerNode, hNodeDef, 0, "PTNodeDef") },
	{ "Rank",					TOK_AUTOINT(ItemTrainablePowerNode, iNodeRank, 1), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemTrainablePowerNode()
{
	int iSize = sizeof(ItemTrainablePowerNode);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemTrainablePowerNode, iSize, "ItemTrainablePowerNode", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct RewardPackInfo
#define TYPE_parse_RewardPackInfo RewardPackInfo
ParseTable parse_RewardPackInfo[] =
{
	{ "RewardPackInfo", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(RewardPackInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hRewardTable",			TOK_STRUCTPARAM | TOK_SERVER_ONLY | TOK_REFERENCE(RewardPackInfo, hRewardTable, 0, "RewardTable") },
	{ "UnpackMessage",			TOK_EMBEDDEDSTRUCT(RewardPackInfo, msgUnpackMessage, parse_DisplayMessage)},
	{ "UnpackFailedMessage",	TOK_EMBEDDEDSTRUCT(RewardPackInfo, msgUnpackFailedMessage, parse_DisplayMessage)},
	{ "RequiredItem",			TOK_REFERENCE(RewardPackInfo, hRequiredItem, 0, "ItemDef") },
	{ "RequiredItemCount",		TOK_AUTOINT(RewardPackInfo, iRequiredItemCount, 1), NULL },
	{ "RequiredItemProduct",	TOK_POOL_STRING | TOK_STRING(RewardPackInfo, pchRequiredItemProduct, 0), NULL },
	{ "ConsumeRequiredItems",	TOK_BIT, 0, 8, NULL},
	{ "PromptRewardChoices",	TOK_BIT, 0, 8, NULL},
	{ "CanScaleRewards",		TOK_BIT, 0, 8, NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_RewardPackInfo()
{
	int iSize = sizeof(RewardPackInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_RewardPackInfo, iSize, "RewardPackInfo", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(RewardPackInfo) + 7) / 4;
		RewardPackInfo *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bConsumeRequiredItems = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_RewardPackInfo[8]);
		pTemp->bConsumeRequiredItems = 0;
		pTemp->bPromptRewardChoices = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_RewardPackInfo[9]);
		pTemp->bPromptRewardChoices = 0;
		pTemp->bCanScaleRewards = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_RewardPackInfo[10]);
		pTemp->bCanScaleRewards = 0;
	}
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemGemUnslotCost
#define TYPE_parse_ItemGemUnslotCost ItemGemUnslotCost
ParseTable parse_ItemGemUnslotCost[] =
{
	{ "ItemGemUnslotCost", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemUnslotCost), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Currency",			TOK_STRING(ItemGemUnslotCost, pchCurrency, 0), NULL },
	{ "ExprBlockRequires",	TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCanUse) },
	{ "ExprRequiresBlock",	TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCanUse) },
	{ "ExprRequires",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCanUse) },
	{ "ExprBlockCost",		TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCost) },
	{ "ExprCostBlock",		TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCost) },
	{ "ExprCost",			TOK_REDUNDANTNAME | TOK_OPTIONALLATEBINDSTRUCT(ItemGemUnslotCost, pExprCost) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemUnslotCost()
{
	int iSize = sizeof(ItemGemUnslotCost);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemUnslotCost, iSize, "ItemGemUnslotCost", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemGemUnslotCost(void)
{
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 3, "Expression");
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 4, "Expression");
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 5, "Expression_StructParam");
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 6, "Expression");
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 7, "Expression");
	DoAutoStructLateBind(parse_ItemGemUnslotCost, 8, "Expression_StructParam");
}
//autogeneratednocheckin
extern ParseTable parse_ItemGemUnslotCost[];
#define TYPE_parse_ItemGemUnslotCost ItemGemUnslotCost
//Structparser.exe autogenerated ParseTable for struct ItemGemConfig
#define TYPE_parse_ItemGemConfig ItemGemConfig
ParseTable parse_ItemGemConfig[] =
{
	{ "ItemGemConfig", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemConfig), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Gemtype",		TOK_STRINGARRAY(ItemGemConfig, ppchGemType), NULL },
	{ "UnslotCost",		TOK_STRUCT(ItemGemConfig, ppUnslotCosts, parse_ItemGemUnslotCost) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemConfig()
{
	int iSize = sizeof(ItemGemConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemConfig, iSize, "ItemGemConfig", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemGemSlotDef
#define TYPE_parse_ItemGemSlotDef ItemGemSlotDef
ParseTable parse_ItemGemSlotDef[] =
{
	{ "ItemGemSlotDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemSlotDef), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "TYPE",			TOK_STRUCTPARAM | TOK_AUTOINT(ItemGemSlotDef, eType, 0), ItemGemTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "PreSlottedGem",	TOK_REFERENCE(ItemGemSlotDef, hPreSlottedGem, 0, "ItemDef") },
	{ "MinLevel",		TOK_AUTOINT(ItemGemSlotDef, iMinLevel, 0), NULL },
	{ "MaxLevel",		TOK_AUTOINT(ItemGemSlotDef, iMaxLevel, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemSlotDef()
{
	int iSize = sizeof(ItemGemSlotDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemSlotDef, iSize, "ItemGemSlotDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemGemSlotFilledInfo
#define TYPE_parse_ItemGemSlotFilledInfo ItemGemSlotFilledInfo
ParseTable parse_ItemGemSlotFilledInfo[] =
{
	{ "ItemGemSlotFilledInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemSlotFilledInfo), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Type",					TOK_AUTOINT(ItemGemSlotFilledInfo, eType, 0), ItemGemTypeEnum },
	{ "IsFilled",				TOK_AUTOINT(ItemGemSlotFilledInfo, bIsFilled, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemSlotFilledInfo()
{
	int iSize = sizeof(ItemGemSlotFilledInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemSlotFilledInfo, iSize, "ItemGemSlotFilledInfo", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDefBonus
#define TYPE_parse_ItemDefBonus ItemDefBonus
ParseTable parse_ItemDefBonus[] =
{
	{ "ItemDefBonus", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDefBonus), 0, NULL, 0, NULL },
	{ "hItem",			TOK_STRUCTPARAM | TOK_REFERENCE(ItemDefBonus, hItem, 0, "ItemDef") },
	{ "\n",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDefBonus()
{
	int iSize = sizeof(ItemDefBonus);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDefBonus, iSize, "ItemDefBonus", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct NumericThresholdDef
#define TYPE_parse_NumericThresholdDef NumericThresholdDef
ParseTable parse_NumericThresholdDef[] =
{
	{ "NumericThresholdDef", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(NumericThresholdDef), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "astrThresholdName",		TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(NumericThresholdDef, astrThresholdName, 0), NULL },
	{ "Alert",					TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "OnlyUGC",				TOK_BIT, 0, 8, NULL},
	{ "OnlyKillCredit",			TOK_BIT, 0, 8, NULL},
	{ "KillCreditLimiter",		TOK_BIT, 0, 8, NULL},
	{ "ThresholdPerLevel",		TOK_INTARRAY(NumericThresholdDef, piThresholdPerLevel),  NULL},
	{ "DurationPerLevel",		TOK_INTARRAY(NumericThresholdDef, puDurationPerLevel),  NULL},
	{ "pfCooldownRatePerLevel",	TOK_NO_TEXT_SAVE | TOK_F32ARRAY(NumericThresholdDef, pfCooldownRatePerLevel), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_NumericThresholdDef()
{
	int iSize = sizeof(NumericThresholdDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_NumericThresholdDef, iSize, "NumericThresholdDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NumericThresholdDef) + 7) / 4;
		NumericThresholdDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bAlert = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NumericThresholdDef[3]);
		pTemp->bAlert = 0;
		pTemp->bOnlyUGC = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NumericThresholdDef[4]);
		pTemp->bOnlyUGC = 0;
		pTemp->bOnlyKillCredit = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NumericThresholdDef[5]);
		pTemp->bOnlyKillCredit = 0;
		pTemp->bKillCreditLimiter = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_NumericThresholdDef[6]);
		pTemp->bKillCreditLimiter = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_ItemPowerDefRef[];
#define TYPE_parse_ItemPowerDefRef ItemPowerDefRef
extern ParseTable parse_ItemTrainablePowerNode[];
#define TYPE_parse_ItemTrainablePowerNode ItemTrainablePowerNode
extern ParseTable parse_InfuseSlotDefRef[];
#define TYPE_parse_InfuseSlotDefRef InfuseSlotDefRef
extern ParseTable parse_ItemDefRef[];
#define TYPE_parse_ItemDefRef ItemDefRef
extern ParseTable parse_ItemDefRef[];
#define TYPE_parse_ItemDefRef ItemDefRef
extern ParseTable parse_ItemGemSlotDef[];
#define TYPE_parse_ItemGemSlotDef ItemGemSlotDef
extern ParseTable parse_ItemVanityPet[];
#define TYPE_parse_ItemVanityPet ItemVanityPet
extern ParseTable parse_RewardPackInfo[];
#define TYPE_parse_RewardPackInfo RewardPackInfo
extern ParseTable parse_ItemCraftingTable[];
#define TYPE_parse_ItemCraftingTable ItemCraftingTable
extern ParseTable parse_UsageRestriction[];
#define TYPE_parse_UsageRestriction UsageRestriction
extern ParseTable parse_ItemEquipLimit[];
#define TYPE_parse_ItemEquipLimit ItemEquipLimit
extern ParseTable parse_ItemCostume[];
#define TYPE_parse_ItemCostume ItemCostume
extern ParseTable parse_ItemDefRef[];
#define TYPE_parse_ItemDefRef ItemDefRef
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
extern ParseTable parse_LoreJournalData[];
#define TYPE_parse_LoreJournalData LoreJournalData
extern ParseTable parse_ItemDefWarp[];
#define TYPE_parse_ItemDefWarp ItemDefWarp
extern ParseTable parse_ItemAttribModifyValues[];
#define TYPE_parse_ItemAttribModifyValues ItemAttribModifyValues
extern ParseTable parse_ItemWeaponDef[];
#define TYPE_parse_ItemWeaponDef ItemWeaponDef
extern ParseTable parse_ItemDamageDef[];
#define TYPE_parse_ItemDamageDef ItemDamageDef
extern ParseTable parse_ItemDefBonus[];
#define TYPE_parse_ItemDefBonus ItemDefBonus
extern ParseTable parse_ItemCostumeClone[];
#define TYPE_parse_ItemCostumeClone ItemCostumeClone
extern ParseTable parse_NumericThresholdDef[];
#define TYPE_parse_NumericThresholdDef NumericThresholdDef
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct ItemDef
#define TYPE_parse_ItemDef ItemDef
ParseTable parse_ItemDef[] =
{
	{ "ItemDef", 							TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDef), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "Name",								TOK_STRUCTPARAM | TOK_POOL_STRING | TOK_KEY | TOK_STRING(ItemDef, pchName, 0), NULL },
	{ "FileName",							TOK_USEROPTIONBIT_1 | TOK_POOL_STRING | TOK_CURRENTFILE(ItemDef, pchFileName), NULL},
	{ "Scope",								TOK_POOL_STRING | TOK_STRING(ItemDef, pchScope, 0), NULL },
	{ "displayNameMsg",						TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, displayNameMsg, parse_DisplayMessage)},
	{ "descriptionMsg",						TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, descriptionMsg, parse_DisplayMessage)},
	{ "descShortMsg",						TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, descShortMsg, parse_DisplayMessage)},
	{ "displayNameMsgUnidentified",			TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, displayNameMsgUnidentified, parse_DisplayMessage)},
	{ "descriptionMsgUnidentified",			TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, descriptionMsgUnidentified, parse_DisplayMessage)},
	{ "msgAutoDesc",						TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, msgAutoDesc, parse_DisplayMessage)},
	{ "Notes",								TOK_STRING(ItemDef, pchNotes, 0), NULL },
	{ "Icon",								TOK_POOL_STRING | TOK_STRING(ItemDef, pchIconName, 0), NULL },
	{ "flags",								TOK_AUTOINT(ItemDef, flags, 0), ItemDefFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "Type",								TOK_AUTOINT(ItemDef, eType, 0), ItemTypeEnum },
	{ "SkillType",							TOK_AUTOINT(ItemDef, kSkillType, 0), SkillTypeEnum },
	{ "Gemtype",							TOK_AUTOINT(ItemDef, eGemType, 0), ItemGemTypeEnum  ,  TOK_FORMAT_FLAGS},
	{ "RestrictBagID",						TOK_INTARRAY(ItemDef, peRestrictBagIDs),  InvBagIDsEnum},
	{ "RestrictBag2ID",						TOK_REDUNDANTNAME | TOK_INTARRAY(ItemDef, peRestrictBagIDs),  InvBagIDsEnum},
	{ "RestrictSlotType",					TOK_AUTOINT(ItemDef, eRestrictSlotType, 0), SlotTypeEnum },
	{ "SlotIDType",							TOK_REFERENCE(ItemDef, hSlotID, 0, "InventorySlotIDDef") },
	{ "StackLimit",							TOK_AUTOINT(ItemDef, iStackLimit, 1), NULL },
	{ "ExprEconomyPoints",					TOK_OPTIONALLATEBINDSTRUCT(ItemDef, pExprEconomyPoints) },
	{ "MinNumericValue",					TOK_AUTOINT(ItemDef, MinNumericValue, S32_MIN+1), NULL },
	{ "MaxNumericValue",					TOK_AUTOINT(ItemDef, MaxNumericValue, S32_MAX), NULL },
	{ "NumericOverflow",					TOK_REFERENCE(ItemDef, hNumericOverflow, 0, "ItemDef") },
	{ "NumericOverflowMulti",				TOK_F32(ItemDef, fNumericOverflowMulti, 0), NULL },
	{ "SpendingNumeric",					TOK_REFERENCE(ItemDef, hSpendingNumeric, 0, "ItemDef") },
	{ "MayBuyInBulk",						TOK_AUTOINT(ItemDef, iMayBuyInBulk, 0), NULL },
	{ "Level",								TOK_AUTOINT(ItemDef, iLevel, 1), NULL },
	{ "Quality",							TOK_AUTOINT(ItemDef, Quality, 0), ItemQualityEnum },
	{ "PowerFactor",						TOK_AUTOINT(ItemDef, iPowerFactor, 0), NULL },
	{ "NumBagSlots",						TOK_AUTOINT(ItemDef, iNumBagSlots, 0), NULL },
	{ "SortID",								TOK_NO_TEXT_SAVE | TOK_AUTOINT(ItemDef, iSortID, 0), NULL },
	{ "ScaleUI",							TOK_F32(ItemDef, fScaleUI, 1), NULL },
	{ "Mission",							TOK_REFERENCE(ItemDef, hMission, 0, "Mission") },
	{ "NewItemPowerDefRefID_DontTouchThis",	TOK_AUTOINT(ItemDef, uNewItemPowerDefRefID, 0), NULL },
	{ "ItemPowerDefRefs",					TOK_STRUCT(ItemDef, ppItemPowerDefRefs, parse_ItemPowerDefRef) },
	{ "TrainableNode",						TOK_STRUCT(ItemDef, ppTrainableNodes, parse_ItemTrainablePowerNode) },
	{ "InfuseSlotDefRefs",					TOK_STRUCT(ItemDef, ppInfuseSlotDefRefs, parse_InfuseSlotDefRef) },
	{ "ItemSet",							TOK_STRUCT(ItemDef, ppItemSets, parse_ItemDefRef) },
	{ "ItemSetMembers",						TOK_NO_TEXT_SAVE | TOK_STRUCT(ItemDef, ppItemSetMembers, parse_ItemDefRef) },
	{ "SuperCritterPet",					TOK_REFERENCE(ItemDef, hSCPdef, 0, "SuperCritterPetDef") },
	{ "ItemGemSlots",						TOK_STRUCT(ItemDef, ppItemGemSlots, parse_ItemGemSlotDef) },
	{ "ItemVanityPetRefs",					TOK_STRUCT(ItemDef, ppItemVanityPetRefs, parse_ItemVanityPet) },
	{ "Subtarget",							TOK_REFERENCE(ItemDef, hSubtarget, 0, "PowerSubtarget") },
	{ "Art",								TOK_REFERENCE(ItemDef, hArt, 0, "ItemArt") },
	{ "Interior",							TOK_REFERENCE(ItemDef, hInterior, 0, "InteriorDef") },
	{ "RewardPackInfo",						TOK_OPTIONALSTRUCT(ItemDef, pRewardPackInfo, parse_RewardPackInfo) },
	{ "RewardTable",						TOK_REDUNDANTNAME | TOK_OPTIONALSTRUCT(ItemDef, pRewardPackInfo, parse_RewardPackInfo) },
	{ "Craft",								TOK_OPTIONALSTRUCT(ItemDef, pCraft, parse_ItemCraftingTable) },
	{ "Restriction",						TOK_OPTIONALSTRUCT(ItemDef, pRestriction, parse_UsageRestriction) },
	{ "EquipLimit",							TOK_OPTIONALSTRUCT(ItemDef, pEquipLimit, parse_ItemEquipLimit) },
	{ "Group",								TOK_AUTOINT(ItemDef, Group, 0), ItemPowerGroupEnum  ,  TOK_FORMAT_FLAGS},
	{ "DyeColor0",							TOK_VEC3(ItemDef, vDyeColor0), NULL },
	{ "DyeColor1",							TOK_VEC3(ItemDef, vDyeColor1), NULL },
	{ "DyeColor2",							TOK_VEC3(ItemDef, vDyeColor2), NULL },
	{ "DyeColor3",							TOK_VEC3(ItemDef, vDyeColor3), NULL },
	{ "hDyeMat",							TOK_REFERENCE(ItemDef, hDyeMat, 0, "PCMaterialAdd") },
	{ "CostumeMode",						TOK_AUTOINT(ItemDef, eCostumeMode, 0), kCostumeDisplayModeEnum },
	{ "CostumePriority",					TOK_AUTOINT(ItemDef, iCostumePriority, 0), NULL },
	{ "Costumes",							TOK_STRUCT(ItemDef, ppCostumes, parse_ItemCostume) },
	{ "Species",							TOK_REFERENCE(ItemDef, hSpecies, 0, "SpeciesDef") },
	{ "CraftRecipe",						TOK_REFERENCE(ItemDef, hCraftRecipe, 0, "ItemDef") },
	{ "Recipe",								TOK_REDUNDANTNAME | TOK_REFERENCE(ItemDef, hCraftRecipe, 0, "ItemDef") },
	{ "ValueRecipe",						TOK_STRUCT(ItemDef, ppValueRecipes, parse_ItemDefRef) },
	{ "calloutMsg",							TOK_EMBEDDEDSTRUCT(ItemDef, calloutMsg, parse_DisplayMessage)},
	{ "calloutFSM",							TOK_STRING(ItemDef, calloutFSM, 0), NULL },
	{ "ImportantCallout",					TOK_AUTOINT(ItemDef, bImportantCallout, 0), NULL },
	{ "LoreCategory",						TOK_AUTOINT(ItemDef, iLoreCategory, 0), LoreCategoryEnum },
	{ "JournalData",						TOK_OPTIONALSTRUCT(ItemDef, pJournalData, parse_LoreJournalData) },
	{ "Tag",								TOK_AUTOINT(ItemDef, eTag, 0), ItemTagEnum },
	{ "Categories",							TOK_INTARRAY(ItemDef, peCategories),  ItemCategoryEnum},
	{ "PetGrant",							TOK_REFERENCE(ItemDef, hPetDef, 0, "PetDef") },
	{ "AlgoPet",							TOK_REFERENCE(ItemDef, hAlgoPet, 0, "AlgoPetDef") },
	{ "Warp",								TOK_OPTIONALSTRUCT(ItemDef, pWarp, parse_ItemDefWarp) },
	{ "MakeAsPuppet",						TOK_BIT, 0, 8, NULL},
	{ "DeleteAfterUnlock",					TOK_BIT, 0, 8, NULL},
	{ "AutoDescDisabled",					TOK_BIT, 0, 8, NULL},
	{ "LogForEconomy",						TOK_BIT, 0, 8, NULL},
	{ "LogForTracking",						TOK_BIT, 0, 8, NULL},
	{ "ItemSetMembersUnique",				TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "UniqueItemSet",						TOK_REDUNDANTNAME | TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ItemSetMembersUseCategories",		TOK_BIT, 0, 8, NULL},
	{ "CostumeIgnoreSkeletonMatching",		TOK_BIT, 0, 8, NULL},
	{ "TrainingDestroysItem",				TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "CouponUsesItemLevel",				TOK_BIT, 0, 8, NULL},
	{ "ExtraSafeRemove",					TOK_BIT, 0, 8, NULL},
	{ "MessageOnTrayActivateFailure",		TOK_BIT, 0, 8, NULL},
	{ "TransmutationHasNoCost",				TOK_BIT, 0, 8, NULL},
	{ "TransmutationEnabled",				TOK_SPECIAL_DEFAULT | TOK_BIT, 0, 8, NULL, 0 , " SPECIAL_DEFAULT = \"1\" "},
	{ "ProgressionEvoInsurance",			TOK_BIT, 0, 8, NULL},
	{ "LogCategory",						TOK_AUTOINT(ItemDef, eLogCategory, 0), enumLogCategoryEnum },
	{ "AttribModifyValues",					TOK_OPTIONALSTRUCT(ItemDef, pAttribModifyValues, parse_ItemAttribModifyValues) },
	{ "Weapon",								TOK_OPTIONALSTRUCT(ItemDef, pItemWeaponDef, parse_ItemWeaponDef) },
	{ "Damage",								TOK_OPTIONALSTRUCT(ItemDef, pItemDamageDef, parse_ItemDamageDef) },
	{ "SpecialPartType",					TOK_AUTOINT(ItemDef, eSpecialPartType, 0), SpecialPartTypeEnum },
	{ "AddedCostumeFX",						TOK_POOL_STRING | TOK_STRING(ItemDef, pcAddedCostumeFX, 0), NULL },
	{ "AddedCostumeBone",					TOK_POOL_STRING | TOK_STRING(ItemDef, pcAddedCostumeBone, 0), NULL },
	{ "GemAddedCostumeFX",					TOK_POOL_STRING | TOK_STRING(ItemDef, pcGemAddedCostumeFX, 0), NULL },
	{ "GemAddedCostumeBone",				TOK_POOL_STRING | TOK_STRING(ItemDef, pcGemAddedCostumeBone, 0), NULL },
	{ "SpecialPartCount",					TOK_AUTOINT(ItemDef, uSpecialPartCount, 0), NULL },
	{ "GamePermission",						TOK_POOL_STRING | TOK_STRING(ItemDef, pchPermission, 0), NULL },
	{ "uExperienceGift",					TOK_AUTOINT(ItemDef, uExperienceGift, 0), NULL },
	{ "uCouponDiscount",					TOK_AUTOINT(ItemDef, uCouponDiscount, 0), NULL },
	{ "MTCategories",						TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRINGARRAY(ItemDef, ppchMTCategories), "MicroTransactionCategory" },
	{ "MTItem",								TOK_GLOBAL_NAME | TOK_POOL_STRING | TOK_STRINGARRAY(ItemDef, ppchMTItems), "MicroTransaction" },
	{ "BonusNumerics",						TOK_STRUCT(ItemDef, eaBonusNumerics, parse_ItemDefBonus) },
	{ "BonusPercent",						TOK_AUTOINT(ItemDef, uBonusPercent, 0), NULL },
	{ "PowerHue",							TOK_F32(ItemDef, fPowerHue, 0), NULL },
	{ "ClonedCostumeRefsForClient",			TOK_NO_TEXT_SAVE | TOK_STRUCT(ItemDef, ppClonedCostumeRefsForClient, parse_ItemCostumeClone) },
	{ "NumericThreshold",					TOK_EDIT_ONLY | TOK_STRUCT(ItemDef, eaNumericThresholdDefs, parse_NumericThresholdDef) },
	{ "TooltipEvent",						TOK_POOL_STRING | TOK_STRING(ItemDef, pchEventTooltipEvent, 0), NULL },
	{ "eventTooltipMsg",					TOK_USEROPTIONBIT_1 | TOK_EMBEDDEDSTRUCT(ItemDef, eventTooltipMsg, parse_DisplayMessage)},
	{ "ProgressionDef",						TOK_REFERENCE(ItemDef, hProgressionDef, 0, "ItemProgressionDef") },
	{ "uProgressionFoodXP",					TOK_AUTOINT(ItemDef, uProgressionFoodXP, 0), NULL },
	{ "uProgressionEvoSuccessBonus",		TOK_AUTOINT(ItemDef, uProgressionEvoSuccessBonus, 0), NULL },
	{ "Slot",								TOK_IGNORE, 0 },
	{ "SubType",							TOK_IGNORE, 0 },
	{ "kSlot",								TOK_IGNORE, 0 },
	{ "Rating",								TOK_IGNORE, 0 },
	{ "EconomyPoints",						TOK_IGNORE, 0 },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ItemDef()
{
	int iSize = sizeof(ItemDef);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDef, iSize, "ItemDef", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(ItemDef) + 7) / 4;
		ItemDef *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bMakeAsPuppet = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[76]);
		pTemp->bMakeAsPuppet = 0;
		pTemp->bDeleteAfterUnlock = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[77]);
		pTemp->bDeleteAfterUnlock = 0;
		pTemp->bAutoDescDisabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[78]);
		pTemp->bAutoDescDisabled = 0;
		pTemp->bLogForEconomy = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[79]);
		pTemp->bLogForEconomy = 0;
		pTemp->bLogForTracking = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[80]);
		pTemp->bLogForTracking = 0;
		pTemp->bItemSetMembersUnique = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[81]);
		pTemp->bItemSetMembersUnique = 0;
		pTemp->bItemSetMembersUnique = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[82]);
		pTemp->bItemSetMembersUnique = 0;
		pTemp->bItemSetMembersUseCategories = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[83]);
		pTemp->bItemSetMembersUseCategories = 0;
		pTemp->bCostumeIgnoreSkeletonMatching = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[84]);
		pTemp->bCostumeIgnoreSkeletonMatching = 0;
		pTemp->bTrainingDestroysItem = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[85]);
		pTemp->bTrainingDestroysItem = 0;
		pTemp->bCouponUsesItemLevel = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[86]);
		pTemp->bCouponUsesItemLevel = 0;
		pTemp->bExtraSafeRemove = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[87]);
		pTemp->bExtraSafeRemove = 0;
		pTemp->bMessageOnTrayActivateFailure = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[88]);
		pTemp->bMessageOnTrayActivateFailure = 0;
		pTemp->bTransmutationHasNoCost = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[89]);
		pTemp->bTransmutationHasNoCost = 0;
		pTemp->bTransmutationEnabled = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[90]);
		pTemp->bTransmutationEnabled = 0;
		pTemp->bProgressionEvoInsurance = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemDef[91]);
		pTemp->bProgressionEvoInsurance = 0;
	}
	parse_ItemDef[34].param = GET_INTPTR_FROM_FLOAT((float)1);
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemDef(void)
{
	DoAutoStructLateBind(parse_ItemDef, 22, "Expression");
}
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemContainerInfo
#define TYPE_parse_ItemContainerInfo ItemContainerInfo
ParseTable parse_ItemContainerInfo[] =
{
	{ "ItemContainerInfo", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemContainerInfo), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "eContainerType",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemContainerInfo, eContainerType, 0), GlobalTypeEnum },
	{ "hSavedPet",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemContainerInfo, hSavedPet, 0, "CopyDict_EntitySavedPet") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemContainerInfo()
{
	int iSize = sizeof(ItemContainerInfo);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemContainerInfo, iSize, "ItemContainerInfo", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDoorKey
#define TYPE_parse_ItemDoorKey ItemDoorKey
ParseTable parse_ItemDoorKey[] =
{
	{ "ItemDoorKey", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDoorKey), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "pchDoorKey",		TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(ItemDoorKey, pchDoorKey, 0), NULL },
	{ "pchMap",			TOK_PERSIST | TOK_POOL_STRING | TOK_SUBSCRIBE | TOK_STRING(ItemDoorKey, pchMap, 0), NULL },
	{ "pchMapVars",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRING(ItemDoorKey, pchMapVars, 0), NULL },
	{ "vPos",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_VEC3(ItemDoorKey, vPos), NULL },
	{ "hMission",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(ItemDoorKey, hMission, 0, "Mission") },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDoorKey()
{
	int iSize = sizeof(ItemDoorKey);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDoorKey, iSize, "ItemDoorKey", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct DyeData
#define TYPE_parse_DyeData DyeData
ParseTable parse_DyeData[] =
{
	{ "DyeData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(DyeData), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "DyeColors",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_FIXED_ARRAY | TOK_AUTOINTARRAY(DyeData, DyeColors), NULL },
	{ "hMat",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(DyeData, hMat, 0, "PCMaterialDef") },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_DyeData()
{
	int iSize = sizeof(DyeData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_DyeData, iSize, "DyeData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemPowerDefRef[];
#define TYPE_parse_ItemPowerDefRef ItemPowerDefRef
extern ParseTable parse_DyeData[];
#define TYPE_parse_DyeData DyeData
//Structparser.exe autogenerated ParseTable for struct AlgoItemProps
#define TYPE_parse_AlgoItemProps AlgoItemProps
ParseTable parse_AlgoItemProps[] =
{
	{ "AlgoItemProps", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(AlgoItemProps), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Quality",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, Quality, 0), ItemQualityEnum },
	{ "MinLevel",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, MinLevel_UseAccessor, 0), NULL },
	{ "MinLevel_UseAccessor",	TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, MinLevel_UseAccessor, 0), NULL },
	{ "Level",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, Level_UseAccessor, 0), NULL },
	{ "Level_UseAccessor",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, Level_UseAccessor, 0), NULL },
	{ "iPowerFactor",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, iPowerFactor, 0), NULL },
	{ "ppItemPowerDefRefs",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(AlgoItemProps, ppItemPowerDefRefs, parse_ItemPowerDefRef) },
	{ "pDyeData",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(AlgoItemProps, pDyeData, parse_DyeData) },
	{ "uProgressionXP",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, uProgressionXP, 0), NULL },
	{ "uProgressionLevel",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(AlgoItemProps, uProgressionLevel, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_AlgoItemProps()
{
	int iSize = sizeof(AlgoItemProps);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_AlgoItemProps, iSize, "AlgoItemProps", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemGemSlotRollResult
#define TYPE_parse_ItemGemSlotRollResult ItemGemSlotRollResult
ParseTable parse_ItemGemSlotRollResult[] =
{
	{ "ItemGemSlotRollResult", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemSlotRollResult), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "uItemPowerDefRefID",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_KEY | TOK_AUTOINT(ItemGemSlotRollResult, uItemPowerDefRefID, 0), NULL },
	{ "bSuccess",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemGemSlotRollResult, bSuccess, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemSlotRollResult()
{
	int iSize = sizeof(ItemGemSlotRollResult);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemSlotRollResult, iSize, "ItemGemSlotRollResult", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemGemSlotRollResult[];
#define TYPE_parse_ItemGemSlotRollResult ItemGemSlotRollResult
//Structparser.exe autogenerated ParseTable for struct ItemGemSlotRollData
#define TYPE_parse_ItemGemSlotRollData ItemGemSlotRollData
ParseTable parse_ItemGemSlotRollData[] =
{
	{ "ItemGemSlotRollData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemSlotRollData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ppRollResults",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(ItemGemSlotRollData, ppRollResults, parse_ItemGemSlotRollResult) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemSlotRollData()
{
	int iSize = sizeof(ItemGemSlotRollData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemSlotRollData, iSize, "ItemGemSlotRollData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_ItemGemSlotRollData[];
#define TYPE_parse_ItemGemSlotRollData ItemGemSlotRollData
//Structparser.exe autogenerated ParseTable for struct ItemGemSlot
#define TYPE_parse_ItemGemSlot ItemGemSlot
ParseTable parse_ItemGemSlot[] =
{
	{ "ItemGemSlot", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemGemSlot), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "hSlottedItem",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemGemSlot, hSlottedItem, 0, "ItemDef") },
	{ "ppPowers",			TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(ItemGemSlot, ppPowers, parse_Power) },
	{ "pRollData",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(ItemGemSlot, pRollData, parse_ItemGemSlotRollData) },
	{ "uProgressionXP",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemGemSlot, uProgressionXP, 0), NULL },
	{ "uProgressionLevel",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemGemSlot, uProgressionLevel, 0), NULL },
	{ "pSlottedItem",		TOK_IGNORE | TOK_IGNORE_STRUCT , 0 },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemGemSlot()
{
	int iSize = sizeof(ItemGemSlot);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemGemSlot, iSize, "ItemGemSlot", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AlgoPet[];
#define TYPE_parse_AlgoPet AlgoPet
extern ParseTable parse_ItemContainerInfo[];
#define TYPE_parse_ItemContainerInfo ItemContainerInfo
extern ParseTable parse_ItemDoorKey[];
#define TYPE_parse_ItemDoorKey ItemDoorKey
extern ParseTable parse_ItemGemSlot[];
#define TYPE_parse_ItemGemSlot ItemGemSlot
extern ParseTable parse_SuperCritterPet[];
#define TYPE_parse_SuperCritterPet SuperCritterPet
extern ParseTable parse_ItemTransmutationProps[];
#define TYPE_parse_ItemTransmutationProps ItemTransmutationProps
//Structparser.exe autogenerated ParseTable for struct SpecialItemProps
#define TYPE_parse_SpecialItemProps SpecialItemProps
ParseTable parse_SpecialItemProps[] =
{
	{ "SpecialItemProps", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(SpecialItemProps), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Costume",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(SpecialItemProps, hCostumeRef, 0, "PlayerCostume") },
	{ "hCostumeRef",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(SpecialItemProps, hCostumeRef, 0, "PlayerCostume") },
	{ "pAlgoPet",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(SpecialItemProps, pAlgoPet, parse_AlgoPet) },
	{ "pContainerInfo",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(SpecialItemProps, pContainerInfo, parse_ItemContainerInfo) },
	{ "pDoorKey",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(SpecialItemProps, pDoorKey, parse_ItemDoorKey) },
	{ "ppItemGemSlots",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(SpecialItemProps, ppItemGemSlots, parse_ItemGemSlot) },
	{ "pSuperCritterPet",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(SpecialItemProps, pSuperCritterPet, parse_SuperCritterPet) },
	{ "pTransmutationProps",	TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(SpecialItemProps, pTransmutationProps, parse_ItemTransmutationProps) },
	{ "hIdentifiedItemDef",		TOK_PERSIST | TOK_SERVER_ONLY | TOK_SUBSCRIBE | TOK_REFERENCE(SpecialItemProps, hIdentifiedItemDef, 0, "ItemDef") },
	{ "fRewardPackScale",		TOK_PERSIST | TOK_SUBSCRIBE | TOK_F32(SpecialItemProps, fRewardPackScale, 1.0f), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_SpecialItemProps()
{
	int iSize = sizeof(SpecialItemProps);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_SpecialItemProps, iSize, "SpecialItemProps", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_SpecialItemProps[11].param = GET_INTPTR_FROM_FLOAT((float)1.0f);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemRewardData
#define TYPE_parse_ItemRewardData ItemRewardData
ParseTable parse_ItemRewardData[] =
{
	{ "ItemRewardData", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemRewardData), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hBroadcastChatMessage",	TOK_REFERENCE(ItemRewardData, hBroadcastChatMessage, 0, "Message") },
	{ "HideInUI",				TOK_AUTOINT(ItemRewardData, bHideInUI, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemRewardData()
{
	int iSize = sizeof(ItemRewardData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemRewardData, iSize, "ItemRewardData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_InfuseSlot[];
#define TYPE_parse_InfuseSlot InfuseSlot
extern ParseTable parse_ItemPowerDefRef[];
#define TYPE_parse_ItemPowerDefRef ItemPowerDefRef
extern ParseTable parse_AlgoPet[];
#define TYPE_parse_AlgoPet AlgoPet
extern ParseTable parse_ItemContainerInfo[];
#define TYPE_parse_ItemContainerInfo ItemContainerInfo
extern ParseTable parse_ItemDoorKey[];
#define TYPE_parse_ItemDoorKey ItemDoorKey
extern ParseTable parse_ItemGemSlot[];
#define TYPE_parse_ItemGemSlot ItemGemSlot
//Structparser.exe autogenerated ParseTable for struct ItemV1
#define TYPE_parse_ItemV1 ItemV1
ParseTable parse_ItemV1[] =
{
	{ "ItemV1", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemV1), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "id",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, id, 0), NULL },
	{ "hItem",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemV1, hItem, 0, "ItemDef") },
	{ "fDurability",				TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_F32(ItemV1, fDurability, 0), NULL },
	{ "fDurabilityMax",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_F32(ItemV1, fDurabilityMax, 0), NULL },
	{ "ppPowers",					TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(ItemV1, ppPowers, parse_Power) },
	{ "ppInfuseSlots",				TOK_PERSIST | TOK_STRUCT(ItemV1, ppInfuseSlots, parse_InfuseSlot) },
	{ "NumericValue",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, iNumericValue, 0), NULL },
	{ "iNumericValue",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, iNumericValue, 0), NULL },
	{ "pchDisplayName",				TOK_ESTRING | TOK_NO_NETSEND | TOK_STRING(ItemV1, pchDisplayName, 0), NULL },
	{ "Quality",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, Quality, 0), ItemQualityEnum },
	{ "MinLevel",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, MinLevel_UseAccessor, 0), NULL },
	{ "MinLevel_UseAccessor",		TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, MinLevel_UseAccessor, 0), NULL },
	{ "Level",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, Level_UseAccessor, 0), NULL },
	{ "Level_UseAccessor",			TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, Level_UseAccessor, 0), NULL },
	{ "iPowerFactor",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, iPowerFactor, 0), NULL },
	{ "flags",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, flags, 0), ItemFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "numeric_op",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(ItemV1, numeric_op, 0), NumericOpEnum  ,  TOK_FORMAT_FLAGS},
	{ "uSetCount",					TOK_SELF_ONLY | TOK_AUTOINT(ItemV1, uSetCount, 0), NULL },
	{ "ppItemPowerDefRefs",			TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_STRUCT(ItemV1, ppItemPowerDefRefs, parse_ItemPowerDefRef) },
	{ "Costume",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemV1, hCostumeRef, 0, "PlayerCostume") },
	{ "hCostumeRef",				TOK_REDUNDANTNAME | TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(ItemV1, hCostumeRef, 0, "PlayerCostume") },
	{ "pAlgoPet",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(ItemV1, pAlgoPet, parse_AlgoPet) },
	{ "pContainerInfo",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(ItemV1, pContainerInfo, parse_ItemContainerInfo) },
	{ "pDoorKey",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_OPTIONALSTRUCT(ItemV1, pDoorKey, parse_ItemDoorKey) },
	{ "hMission",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_REFERENCE(ItemV1, hMission, 0, "Mission") },
	{ "ppItemGemSlots",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_STRUCT(ItemV1, ppItemGemSlots, parse_ItemGemSlot) },
	{ "uiTimestamp",				TOK_SELF_ONLY | TOK_AUTOINT(ItemV1, uiTimestamp, 0), NULL },
	{ "owner",						TOK_AUTOINT(ItemV1, owner, 0), NULL },
	{ "iWarpChargesUsed",			TOK_PERSIST | TOK_SOMETIMES_TRANSACT | TOK_AUTOINT(ItemV1, iWarpChargesUsed, 0), NULL },
	{ "bWarpActive",				TOK_BIT, 0, 8, NULL},
	{ "bTrainingFromItem",			TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bSlottedOnItemAssignment",	TOK_PERSIST | TOK_BIT, 0, 8, NULL},
	{ "bAlgo",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_BIT, 0, 8, NULL},
	{ "bUnlootable",				TOK_BIT, 0, 8, NULL},
	{ "bExemptFromLootMode",		TOK_BIT, 0, 8, NULL},
	{ "bTransactionPending",		TOK_BIT, 0, 8, NULL},
	{ "bForceBind",					TOK_BIT, 0, 8, NULL},
	{ "iPendingTransactionCount",	TOK_AUTOINT(ItemV1, iPendingTransactionCount, 0), NULL },
	{ "bHide",						TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ItemV1()
{
	int iSize = sizeof(ItemV1);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemV1, iSize, "ItemV1", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(ItemV1)) + 7) / 4;
		NOCONST(ItemV1) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bWarpActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[31]);
		pTemp->bWarpActive = 0;
		pTemp->bTrainingFromItem = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[32]);
		pTemp->bTrainingFromItem = 0;
		pTemp->bSlottedOnItemAssignment = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[33]);
		pTemp->bSlottedOnItemAssignment = 0;
		pTemp->bAlgo = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[34]);
		pTemp->bAlgo = 0;
		pTemp->bUnlootable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[35]);
		pTemp->bUnlootable = 0;
		pTemp->bExemptFromLootMode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[36]);
		pTemp->bExemptFromLootMode = 0;
		pTemp->bTransactionPending = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[37]);
		pTemp->bTransactionPending = 0;
		pTemp->bForceBind = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemV1[38]);
		pTemp->bForceBind = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Item[];
#define TYPE_parse_Item Item
//Structparser.exe autogenerated ParseTable for struct ItemBuyBack
#define TYPE_parse_ItemBuyBack ItemBuyBack
ParseTable parse_ItemBuyBack[] =
{
	{ "ItemBuyBack", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemBuyBack), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "uBuyBackId",		TOK_SELF_ONLY | TOK_KEY | TOK_AUTOINT(ItemBuyBack, uBuyBackId, 0), NULL },
	{ "Item",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(ItemBuyBack, pItem, parse_Item) },
	{ "Status",			TOK_SELF_ONLY | TOK_AUTOINT(ItemBuyBack, eStatus, 0), ItemBuyBackStatusEnum },
	{ "uBuyBackPrice",	TOK_SELF_ONLY | TOK_AUTOINT(ItemBuyBack, uBuyBackPrice, 0), NULL },
	{ "Currency",		TOK_SELF_ONLY | TOK_POOL_STRING | TOK_STRING(ItemBuyBack, pcCurrency, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemBuyBack()
{
	int iSize = sizeof(ItemBuyBack);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemBuyBack, iSize, "ItemBuyBack", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_AlgoItemProps[];
#define TYPE_parse_AlgoItemProps AlgoItemProps
extern ParseTable parse_SpecialItemProps[];
#define TYPE_parse_SpecialItemProps SpecialItemProps
extern ParseTable parse_Power[];
#define TYPE_parse_Power Power
extern ParseTable parse_ItemRewardData[];
#define TYPE_parse_ItemRewardData ItemRewardData
//Structparser.exe autogenerated ParseTable for struct Item
#define TYPE_parse_Item Item
ParseTable parse_Item[] =
{
	{ "Item", 						TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(Item), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "id",							TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Item, id, 0), NULL },
	{ "hItem",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_REFERENCE(Item, hItem, 0, "ItemDef") },
	{ "pchDisplayName",				TOK_ESTRING | TOK_NO_NETSEND | TOK_STRING(Item, pchDisplayName, 0), NULL },
	{ "pAlgoProps",					TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Item, pAlgoProps, parse_AlgoItemProps) },
	{ "pSpecialProps",				TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_OPTIONALSTRUCT(Item, pSpecialProps, parse_SpecialItemProps) },
	{ "ppPowers",					TOK_PERSIST | TOK_NO_INDEX | TOK_SUBSCRIBE | TOK_STRUCT(Item, ppPowers, parse_Power) },
	{ "flags",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Item, flags, 0), ItemFlagEnum  ,  TOK_FORMAT_FLAGS},
	{ "count",						TOK_PERSIST | TOK_SUBSCRIBE | TOK_LOGIN_SUBSCRIBE | TOK_AUTOINT(Item, count, 1), NULL },
	{ "numeric_op",					TOK_AUTOINT(Item, numeric_op, 0), NULL },
	{ "pRewardData",				TOK_SERVER_ONLY | TOK_OPTIONALSTRUCT(Item, pRewardData, parse_ItemRewardData) },
	{ "uSetCount",					TOK_SELF_ONLY | TOK_AUTOINT(Item, uSetCount, 0), NULL },
	{ "hBroadcastChatMessage",		TOK_SERVER_ONLY | TOK_REFERENCE(Item, hBroadcastChatMessage, 0, "Message") },
	{ "owner",						TOK_AUTOINT(Item, owner, 0), NULL },
	{ "bWarpActive",				TOK_BIT, 0, 8, NULL},
	{ "bUnlootable",				TOK_BIT, 0, 8, NULL},
	{ "bExemptFromLootMode",		TOK_BIT, 0, 8, NULL},
	{ "bTransactionPending",		TOK_BIT, 0, 8, NULL},
	{ "bForceBind",					TOK_BIT, 0, 8, NULL},
	{ "iPendingTransactionCount",	TOK_AUTOINT(Item, iPendingTransactionCount, 0), NULL },
	{ "bHide",						TOK_IGNORE, 0 },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_Item()
{
	int iSize = sizeof(Item);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_Item, iSize, "Item", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(NOCONST(Item)) + 7) / 4;
		NOCONST(Item) *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bWarpActive = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Item[15]);
		pTemp->bWarpActive = 0;
		pTemp->bUnlootable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Item[16]);
		pTemp->bUnlootable = 0;
		pTemp->bExemptFromLootMode = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Item[17]);
		pTemp->bExemptFromLootMode = 0;
		pTemp->bTransactionPending = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Item[18]);
		pTemp->bTransactionPending = 0;
		pTemp->bForceBind = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_Item[19]);
		pTemp->bForceBind = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
//Structparser.exe autogenerated ParseTable for struct ItemRewardPackRequest
#define TYPE_parse_ItemRewardPackRequest ItemRewardPackRequest
ParseTable parse_ItemRewardPackRequest[] =
{
	{ "ItemRewardPackRequest", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemRewardPackRequest), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "RewardBags",				TOK_NO_INDEX | TOK_STRUCT(ItemRewardPackRequest, eaRewardBags, parse_InventoryBag) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemRewardPackRequest()
{
	int iSize = sizeof(ItemRewardPackRequest);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemRewardPackRequest, iSize, "ItemRewardPackRequest", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InventoryBag[];
#define TYPE_parse_InventoryBag InventoryBag
//Structparser.exe autogenerated ParseTable for struct GiveRewardBagsData
#define TYPE_parse_GiveRewardBagsData GiveRewardBagsData
ParseTable parse_GiveRewardBagsData[] =
{
	{ "GiveRewardBagsData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(GiveRewardBagsData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "RewardBags",			TOK_NO_INDEX | TOK_STRUCT(GiveRewardBagsData, ppRewardBags, parse_InventoryBag) },
	{ "Choices",			TOK_STRINGARRAY(GiveRewardBagsData, ppChoices), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_GiveRewardBagsData()
{
	int iSize = sizeof(GiveRewardBagsData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_GiveRewardBagsData, iSize, "GiveRewardBagsData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct InventorySlotReference
#define TYPE_parse_InventorySlotReference InventorySlotReference
ParseTable parse_InventorySlotReference[] =
{
	{ "InventorySlotReference", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(InventorySlotReference), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "BagID",					TOK_AUTOINT(InventorySlotReference, eBagID, InvBagIDs_None), InvBagIDsEnum },
	{ "Index",					TOK_AUTOINT(InventorySlotReference, iIndex, -1), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_InventorySlotReference()
{
	int iSize = sizeof(InventorySlotReference);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_InventorySlotReference, iSize, "InventorySlotReference", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ExperimentEntry
#define TYPE_parse_ExperimentEntry ExperimentEntry
ParseTable parse_ExperimentEntry[] =
{
	{ "ExperimentEntry", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ExperimentEntry), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "SrcBagId",			TOK_AUTOINT(ExperimentEntry, SrcBagId, 0), NULL },
	{ "SrcSlot",			TOK_AUTOINT(ExperimentEntry, SrcSlot, 0), NULL },
	{ "count",				TOK_AUTOINT(ExperimentEntry, count, 0), NULL },
	{ "EPValue",			TOK_AUTOINT(ExperimentEntry, iEPValue, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ExperimentEntry()
{
	int iSize = sizeof(ExperimentEntry);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ExperimentEntry, iSize, "ExperimentEntry", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ExperimentEntry[];
#define TYPE_parse_ExperimentEntry ExperimentEntry
//Structparser.exe autogenerated ParseTable for struct ExperimentData
#define TYPE_parse_ExperimentData ExperimentData
ParseTable parse_ExperimentData[] =
{
	{ "ExperimentData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ExperimentData), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "Entry",			TOK_STRUCT(ExperimentData, ppEntry, parse_ExperimentEntry) },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ExperimentData()
{
	int iSize = sizeof(ExperimentData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ExperimentData, iSize, "ExperimentData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ExperimentRanges
#define TYPE_parse_ExperimentRanges ExperimentRanges
ParseTable parse_ExperimentRanges[] =
{
	{ "ExperimentRanges", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ExperimentRanges), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "eaiRanges",			TOK_INTARRAY(ExperimentRanges, eaiRanges),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ExperimentRanges()
{
	int iSize = sizeof(ExperimentRanges);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ExperimentRanges, iSize, "ExperimentRanges", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CraftData
#define TYPE_parse_CraftData CraftData
ParseTable parse_CraftData[] =
{
	{ "CraftData", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CraftData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Quality",			TOK_AUTOINT(CraftData, eQuality, 0), ItemQualityEnum },
	{ "BaseItemRecipeName",	TOK_STRING(CraftData, pcBaseItemRecipeName, 0), NULL },
	{ "ItemPowerRecipes",	TOK_STRINGARRAY(CraftData, eaItemPowerRecipes), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CraftData()
{
	int iSize = sizeof(CraftData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CraftData, iSize, "CraftData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct CraftSkillupRanges
#define TYPE_parse_CraftSkillupRanges CraftSkillupRanges
ParseTable parse_CraftSkillupRanges[] =
{
	{ "CraftSkillupRanges", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(CraftSkillupRanges), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "eaiRanges",			TOK_INTARRAY(CraftSkillupRanges, eaiRanges),  NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_CraftSkillupRanges()
{
	int iSize = sizeof(CraftSkillupRanges);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_CraftSkillupRanges, iSize, "CraftSkillupRanges", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemDeconstructSkillDefault
#define TYPE_parse_ItemDeconstructSkillDefault ItemDeconstructSkillDefault
ParseTable parse_ItemDeconstructSkillDefault[] =
{
	{ "ItemDeconstructSkillDefault", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDeconstructSkillDefault), 0, NULL, 0, NULL },
	{ "{",								TOK_START, 0 },
	{ "SkillType",						TOK_STRUCTPARAM | TOK_AUTOINT(ItemDeconstructSkillDefault, eSkillType, 0), SkillTypeEnum },
	{ "PrimaryRecipe",					TOK_REFERENCE(ItemDeconstructSkillDefault, hPrimaryRecipe, 0, "ItemDef") },
	{ "SecondaryRecipe",				TOK_REFERENCE(ItemDeconstructSkillDefault, hSecondaryRecipe, 0, "ItemDef") },
	{ "DeviceRecipe",					TOK_REFERENCE(ItemDeconstructSkillDefault, hDeviceRecipe, 0, "ItemDef") },
	{ "}",								TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDeconstructSkillDefault()
{
	int iSize = sizeof(ItemDeconstructSkillDefault);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDeconstructSkillDefault, iSize, "ItemDeconstructSkillDefault", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemDeconstructSkillDefault[];
#define TYPE_parse_ItemDeconstructSkillDefault ItemDeconstructSkillDefault
//Structparser.exe autogenerated ParseTable for struct ItemDeconstructDefaults
#define TYPE_parse_ItemDeconstructDefaults ItemDeconstructDefaults
ParseTable parse_ItemDeconstructDefaults[] =
{
	{ "ItemDeconstructDefaults", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemDeconstructDefaults), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "SkillDefault",				TOK_STRUCT(ItemDeconstructDefaults, peaSkillDefaults, parse_ItemDeconstructSkillDefault) },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemDeconstructDefaults()
{
	int iSize = sizeof(ItemDeconstructDefaults);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemDeconstructDefaults, iSize, "ItemDeconstructDefaults", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemSortType
#define TYPE_parse_ItemSortType ItemSortType
ParseTable parse_ItemSortType[] =
{
	{ "ItemSortType", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemSortType), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "NameMsg",			TOK_REFERENCE(ItemSortType, hNameMsg, 0, "Message") },
	{ "SortID",				TOK_KEY | TOK_AUTOINT(ItemSortType, iSortID, 0), NULL },
	{ "Searchable",			TOK_AUTOINT(ItemSortType, bSearchable, 0), NULL },
	{ "LevelIgnored",		TOK_AUTOINT(ItemSortType, bLevelIgnored, 0), NULL },
	{ "Type",				TOK_AUTOINT(ItemSortType, eType, 0), ItemTypeEnum },
	{ "Type2",				TOK_AUTOINT(ItemSortType, eType2, 0), ItemTypeEnum },
	{ "RestrictBagID",		TOK_AUTOINT(ItemSortType, eRestrictBagID, 0), InvBagIDsEnum },
	{ "RestrictSlotType",	TOK_AUTOINT(ItemSortType, eRestrictSlotType, 0), SlotTypeEnum },
	{ "ItemCategory",		TOK_AUTOINT(ItemSortType, eItemCategory, 0), ItemCategoryEnum },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemSortType()
{
	int iSize = sizeof(ItemSortType);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemSortType, iSize, "ItemSortType", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemSortTypeCategory
#define TYPE_parse_ItemSortTypeCategory ItemSortTypeCategory
ParseTable parse_ItemSortTypeCategory[] =
{
	{ "ItemSortTypeCategory", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemSortTypeCategory), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Name",					TOK_POOL_STRING | TOK_KEY | TOK_STRING(ItemSortTypeCategory, pchName, 0), NULL },
	{ "NameMsg",				TOK_REFERENCE(ItemSortTypeCategory, hNameMsg, 0, "Message") },
	{ "ItemSortTypes",			TOK_INTARRAY(ItemSortTypeCategory, eaiItemSortTypes),  NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemSortTypeCategory()
{
	int iSize = sizeof(ItemSortTypeCategory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemSortTypeCategory, iSize, "ItemSortTypeCategory", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemSortTypeCategory[];
#define TYPE_parse_ItemSortTypeCategory ItemSortTypeCategory
extern ParseTable parse_ItemSortType[];
#define TYPE_parse_ItemSortType ItemSortType
extern ParseTable parse_ItemSortType[];
#define TYPE_parse_ItemSortType ItemSortType
//Structparser.exe autogenerated ParseTable for struct ItemSortTypes
#define TYPE_parse_ItemSortTypes ItemSortTypes
ParseTable parse_ItemSortTypes[] =
{
	{ "ItemSortTypes", 			TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemSortTypes), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "ItemSortTypeCategory",	TOK_NO_INDEX | TOK_STRUCT(ItemSortTypes, ppItemSortTypeCategories, parse_ItemSortTypeCategory) },
	{ "ItemSortType",			TOK_NO_INDEX | TOK_STRUCT(ItemSortTypes, ppItemSortType, parse_ItemSortType) },
	{ "IndexedItemSortTypes",	TOK_NO_TEXT_SAVE | TOK_UNOWNED | TOK_STRUCT(ItemSortTypes, ppIndexedItemSortTypes, parse_ItemSortType) },
	{ "FileName",				TOK_POOL_STRING | TOK_CURRENTFILE(ItemSortTypes, pchFileName), NULL},
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemSortTypes()
{
	int iSize = sizeof(ItemSortTypes);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemSortTypes, iSize, "ItemSortTypes", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_DisplayMessage[];
#define TYPE_parse_DisplayMessage DisplayMessage
//Structparser.exe autogenerated ParseTable for struct ItemAliasDisplay
#define TYPE_parse_ItemAliasDisplay ItemAliasDisplay
ParseTable parse_ItemAliasDisplay[] =
{
	{ "ItemAliasDisplay", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemAliasDisplay), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "DisplayNameMessage",	TOK_EMBEDDEDSTRUCT(ItemAliasDisplay, DisplayNameMessage, parse_DisplayMessage)},
	{ "RequiredAllegiance",	TOK_REFERENCE(ItemAliasDisplay, hRequiredAllegiance, 0, "AllegianceDef") },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemAliasDisplay()
{
	int iSize = sizeof(ItemAliasDisplay);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemAliasDisplay, iSize, "ItemAliasDisplay", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemAliasDisplay[];
#define TYPE_parse_ItemAliasDisplay ItemAliasDisplay
//Structparser.exe autogenerated ParseTable for struct ItemAlias
#define TYPE_parse_ItemAlias ItemAlias
ParseTable parse_ItemAlias[] =
{
	{ "ItemAlias", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemAlias), 0, NULL, 0, NULL },
	{ "{",			TOK_START, 0 },
	{ "Alias",		TOK_STRUCTPARAM | TOK_KEY | TOK_STRING(ItemAlias, pchAlias, 0), NULL },
	{ "Item",		TOK_REFERENCE(ItemAlias, hItem, 0, "ItemDef") },
	{ "Choice",		TOK_STRUCT(ItemAlias, ppChoices, parse_ItemAliasDisplay) },
	{ "}",			TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemAlias()
{
	int iSize = sizeof(ItemAlias);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemAlias, iSize, "ItemAlias", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemAlias[];
#define TYPE_parse_ItemAlias ItemAlias
//Structparser.exe autogenerated ParseTable for struct ItemAliasLookup
#define TYPE_parse_ItemAliasLookup ItemAliasLookup
ParseTable parse_ItemAliasLookup[] =
{
	{ "ItemAliasLookup", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemAliasLookup), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Alias",				TOK_STRUCT(ItemAliasLookup, ppAlias, parse_ItemAlias) },
	{ "FileName",			TOK_POOL_STRING | TOK_CURRENTFILE(ItemAliasLookup, pchFileName), NULL},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemAliasLookup()
{
	int iSize = sizeof(ItemAliasLookup);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemAliasLookup, iSize, "ItemAliasLookup", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemAcquireOverride
#define TYPE_parse_ItemAcquireOverride ItemAcquireOverride
ParseTable parse_ItemAcquireOverride[] =
{
	{ "ItemAcquireOverride", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemAcquireOverride), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "itemType",				TOK_KEY | TOK_AUTOINT(ItemAcquireOverride, itemType, 0), ItemTypeEnum },
	{ "fromMail",				TOK_BOOLFLAG(ItemAcquireOverride, fromMail, 0), NULL },
	{ "fromTrade",				TOK_BOOLFLAG(ItemAcquireOverride, fromTrade, 0), NULL },
	{ "fromStore",				TOK_BOOLFLAG(ItemAcquireOverride, fromStore, 0), NULL },
	{ "fromAuction",			TOK_BOOLFLAG(ItemAcquireOverride, fromAuction, 0), NULL },
	{ "fromGameAction",			TOK_BOOLFLAG(ItemAcquireOverride, fromGameAction, 0), NULL },
	{ "fromMissionReward",		TOK_BOOLFLAG(ItemAcquireOverride, fromMissionReward, 0), NULL },
	{ "PreferredRestrictBag",	TOK_AUTOINT(ItemAcquireOverride, ePreferredRestrictBag, 0), InvBagIDsEnum },
	{ "BagFullError",			TOK_REFERENCE(ItemAcquireOverride, bagFullError, 0, "Message") },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemAcquireOverride()
{
	int iSize = sizeof(ItemAcquireOverride);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemAcquireOverride, iSize, "ItemAcquireOverride", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemAcquireOverride[];
#define TYPE_parse_ItemAcquireOverride ItemAcquireOverride
//Structparser.exe autogenerated ParseTable for struct ItemHandlingConfig
#define TYPE_parse_ItemHandlingConfig ItemHandlingConfig
ParseTable parse_ItemHandlingConfig[] =
{
	{ "ItemHandlingConfig", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemHandlingConfig), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "AcquireOverride",	TOK_STRUCT(ItemHandlingConfig, overrideList, parse_ItemAcquireOverride) },
	{ "TradeableBag",		TOK_INTARRAY(ItemHandlingConfig, tradeableBags),  InvBagIDsEnum},
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemHandlingConfig()
{
	int iSize = sizeof(ItemHandlingConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemHandlingConfig, iSize, "ItemHandlingConfig", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_Entity[];
#define TYPE_parse_Entity Entity
extern ParseTable parse_ItemDef[];
#define TYPE_parse_ItemDef ItemDef
//Structparser.exe autogenerated ParseTable for struct ItemTimestampData
#define TYPE_parse_ItemTimestampData ItemTimestampData
ParseTable parse_ItemTimestampData[] =
{
	{ "ItemTimestampData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemTimestampData), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Ent",				TOK_UNOWNED | TOK_OPTIONALSTRUCT(ItemTimestampData, pEnt, parse_Entity) },
	{ "ItemDef",			TOK_UNOWNED | TOK_OPTIONALSTRUCT(ItemTimestampData, pItemDef, parse_ItemDef) },
	{ "uiTime",				TOK_AUTOINT(ItemTimestampData, uiTime, 0), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemTimestampData()
{
	int iSize = sizeof(ItemTimestampData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemTimestampData, iSize, "ItemTimestampData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvRewardRequest[];
#define TYPE_parse_InvRewardRequest InvRewardRequest
//Structparser.exe autogenerated ParseTable for struct ItemRewardPackTransferData
#define TYPE_parse_ItemRewardPackTransferData ItemRewardPackTransferData
ParseTable parse_ItemRewardPackTransferData[] =
{
	{ "ItemRewardPackTransferData", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemRewardPackTransferData), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "hRewardPackItem",			TOK_REFERENCE(ItemRewardPackTransferData, hRewardPackItem, 0, "ItemDef") },
	{ "PackResultQuality",			TOK_AUTOINT(ItemRewardPackTransferData, ePackResultQuality, 0), ItemQualityEnum },
	{ "Rewards",					TOK_OPTIONALSTRUCT(ItemRewardPackTransferData, pRewards, parse_InvRewardRequest) },
	{ "RewardPackType",				TOK_AUTOINT(ItemRewardPackTransferData, eRewardPackType, 0), ItemRewardPackTypeEnum },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemRewardPackTransferData()
{
	int iSize = sizeof(ItemRewardPackTransferData);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemRewardPackTransferData, iSize, "ItemRewardPackTransferData", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemRestrictBagToFxMap
#define TYPE_parse_ItemRestrictBagToFxMap ItemRestrictBagToFxMap
ParseTable parse_ItemRestrictBagToFxMap[] =
{
	{ "ItemRestrictBagToFxMap", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemRestrictBagToFxMap), 0, NULL, 0, NULL },
	{ "ID",						TOK_STRUCTPARAM | TOK_AUTOINT(ItemRestrictBagToFxMap, eID, 0), InvBagIDsEnum },
	{ "SlotType",				TOK_STRUCTPARAM | TOK_AUTOINT(ItemRestrictBagToFxMap, eSlotType, 0), SlotTypeEnum },
	{ "FXName",					TOK_STRUCTPARAM | TOK_STRING(ItemRestrictBagToFxMap, pchFXName, 0), NULL },
	{ "\n",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemRestrictBagToFxMap()
{
	int iSize = sizeof(ItemRestrictBagToFxMap);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemRestrictBagToFxMap, iSize, "ItemRestrictBagToFxMap", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct ItemHeadshotStyleConfig
#define TYPE_parse_ItemHeadshotStyleConfig ItemHeadshotStyleConfig
ParseTable parse_ItemHeadshotStyleConfig[] =
{
	{ "ItemHeadshotStyleConfig", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemHeadshotStyleConfig), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "HeadshotStyleDef",			TOK_STRUCTPARAM | TOK_STRING(ItemHeadshotStyleConfig, pchHeadshotStyleDef, 0), NULL },
	{ "RestrictBag",				TOK_AUTOINT(ItemHeadshotStyleConfig, eRestrictBag, 0), InvBagIDsEnum },
	{ "Category",					TOK_INTARRAY(ItemHeadshotStyleConfig, eaCategories),  ItemCategoryEnum},
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_ItemHeadshotStyleConfig()
{
	int iSize = sizeof(ItemHeadshotStyleConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemHeadshotStyleConfig, iSize, "ItemHeadshotStyleConfig", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_ItemRestrictBagToFxMap[];
#define TYPE_parse_ItemRestrictBagToFxMap ItemRestrictBagToFxMap
extern ParseTable parse_ItemHeadshotStyleConfig[];
#define TYPE_parse_ItemHeadshotStyleConfig ItemHeadshotStyleConfig
//Structparser.exe autogenerated ParseTable for struct ItemConfig
#define TYPE_parse_ItemConfig ItemConfig
ParseTable parse_ItemConfig[] =
{
	{ "ItemConfig", 							TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(ItemConfig), 0, NULL, 0, NULL },
	{ "{",									TOK_START, 0 },
	{ "UseUniqueIDsForItemPowerDefRefs",	TOK_BIT, 0, 8, NULL},
	{ "ItemTypeEquippedFX",					TOK_STRUCT(ItemConfig, eaBagToFxMaps, parse_ItemRestrictBagToFxMap) },
	{ "ItemTransmuteCost",					TOK_OPTIONALLATEBINDSTRUCT(ItemConfig, pItemTransmuteCost) },
	{ "ItemTransmuteCurrency",				TOK_POOL_STRING | TOK_STRING(ItemConfig, pchTransmuteCurrencyName, 0), NULL },
	{ "HeadshotStyleConfig",				TOK_STRUCT(ItemConfig, eaHeadshotStyleConfigs, parse_ItemHeadshotStyleConfig) },
	{ "}",									TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_ItemConfig()
{
	int iSize = sizeof(ItemConfig);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_ItemConfig, iSize, "ItemConfig", NULL, "itemCommon.h", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(ItemConfig) + 7) / 4;
		ItemConfig *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bUseUniqueIDsForItemPowerDefRefs = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_ItemConfig[2]);
		pTemp->bUseUniqueIDsForItemPowerDefRefs = 0;
	}
	return 0;
};
void DoAutoStructLateBind(ParseTable *pTPI, int iColumnIndex, char *pOtherTPIName);
void autoStruct_lateFixup_ItemConfig(void)
{
	DoAutoStructLateBind(parse_ItemConfig, 4, "Expression");
}
