#include "textparser.h"
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct OwnedContainer
#define TYPE_parse_OwnedContainer OwnedContainer
ParseTable parse_OwnedContainer[] =
{
	{ "OwnedContainer", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(OwnedContainer), 0, NULL, 0, NULL },
	{ "{",				TOK_START, 0 },
	{ "id",				TOK_AUTOINT(OwnedContainer, id, 0), NULL },
	{ "}",				TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_OwnedContainer()
{
	int iSize = sizeof(OwnedContainer);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_OwnedContainer, iSize, "OwnedContainer", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MappedInvBag[];
#define TYPE_parse_MappedInvBag MappedInvBag
extern ParseTable parse_MappedInvBag[];
#define TYPE_parse_MappedInvBag MappedInvBag
extern ParseTable parse_MappedInvSlot[];
#define TYPE_parse_MappedInvSlot MappedInvSlot
extern ParseTable parse_MappedInvSlot[];
#define TYPE_parse_MappedInvSlot MappedInvSlot
extern ParseTable parse_MappedInvSlot[];
#define TYPE_parse_MappedInvSlot MappedInvSlot
//Structparser.exe autogenerated ParseTable for struct MappedInventory
#define TYPE_parse_MappedInventory MappedInventory
ParseTable parse_MappedInventory[] =
{
	{ "MappedInventory", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedInventory), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "Bags",				TOK_STRUCT(MappedInventory, ppBags, parse_MappedInvBag) },
	{ "PlayerBags",			TOK_SELF_ONLY | TOK_STRUCT(MappedInventory, ppPlayerBags, parse_MappedInvBag) },
	{ "NotAssignedSlots",	TOK_SELF_ONLY | TOK_STRUCT(MappedInventory, ppNotAssignedSlots, parse_MappedInvSlot) },
	{ "AssignedSlots",		TOK_SELF_ONLY | TOK_STRUCT(MappedInventory, ppAssignedSlots, parse_MappedInvSlot) },
	{ "TradeBag",			TOK_SELF_ONLY | TOK_STRUCT(MappedInventory, ppTradeItems, parse_MappedInvSlot) },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MappedInventory()
{
	int iSize = sizeof(MappedInventory);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedInventory, iSize, "MappedInventory", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MappedAttribs
#define TYPE_parse_MappedAttribs MappedAttribs
ParseTable parse_MappedAttribs[] =
{
	{ "MappedAttribs", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedAttribs), 0, NULL, 0, NULL },
	{ "{",					TOK_START, 0 },
	{ "STR",				TOK_F32(MappedAttribs, fStr, -1), NULL },
	{ "CON",				TOK_F32(MappedAttribs, fCon, -1), NULL },
	{ "DEX",				TOK_F32(MappedAttribs, fDex, -1), NULL },
	{ "INT",				TOK_F32(MappedAttribs, fInt, -1), NULL },
	{ "WIS",				TOK_F32(MappedAttribs, fWis, -1), NULL },
	{ "CHA",				TOK_F32(MappedAttribs, fCha, -1), NULL },
	{ "stat_power",			TOK_F32(MappedAttribs, fPower, -1), NULL },
	{ "stat_crit",			TOK_F32(MappedAttribs, fCrit, -1), NULL },
	{ "stat_ArmorPen",		TOK_F32(MappedAttribs, fArmorPen, -1), NULL },
	{ "stat_Recovery",		TOK_F32(MappedAttribs, fRecovery, -1), NULL },
	{ "stat_Defense",		TOK_F32(MappedAttribs, fDefense, -1), NULL },
	{ "stat_Regen",			TOK_F32(MappedAttribs, fRegen, -1), NULL },
	{ "stat_HealthSteal",	TOK_F32(MappedAttribs, fLifeSteal, -1), NULL },
	{ "stat_Movement",		TOK_F32(MappedAttribs, fMovement, -1), NULL },
	{ "stat_Deflect",		TOK_F32(MappedAttribs, fDeflect, -1), NULL },
	{ "HitPointsMax",		TOK_F32(MappedAttribs, fHitPointsMax, -1), NULL },
	{ "AC",					TOK_F32(MappedAttribs, fArmorClass, -1), NULL },
	{ "MagicAC",			TOK_F32(MappedAttribs, fMagicArmorClass, -1), NULL },
	{ "}",					TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MappedAttribs()
{
	int iSize = sizeof(MappedAttribs);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedAttribs, iSize, "MappedAttribs", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	parse_MappedAttribs[2].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[3].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[4].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[5].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[6].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[7].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[8].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[9].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[10].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[11].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[12].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[13].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[14].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[15].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[16].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[17].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[18].param = GET_INTPTR_FROM_FLOAT((float)-1);
	parse_MappedAttribs[19].param = GET_INTPTR_FROM_FLOAT((float)-1);
	return 0;
};
//autogeneratednocheckin
//Structparser.exe autogenerated ParseTable for struct MappedCurrencies
#define TYPE_parse_MappedCurrencies MappedCurrencies
ParseTable parse_MappedCurrencies[] =
{
	{ "MappedCurrencies", 		TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedCurrencies), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Gold",					TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iGold, 0), NULL },
	{ "Silver",					TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iSilver, 0), NULL },
	{ "Copper",					TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iCopper, 0), NULL },
	{ "Diamonds",				TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iDiamonds, 0), NULL },
	{ "FoundryTips",			TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iFoundryTips, 0), NULL },
	{ "RoughDiamonds",			TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iRoughDiamonds, 0), NULL },
	{ "Ardent",					TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iArdent, 0), NULL },
	{ "Celestial",				TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iCelestial, 0), NULL },
	{ "Glory",					TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iGlory, 0), NULL },
	{ "DiamondsConvertLeft",	TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iDiamondsConvertLeft, 0), NULL },
	{ "DiamondsConverted",		TOK_SELF_ONLY | TOK_AUTOINT(MappedCurrencies, iDiamondsConverted, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MappedCurrencies()
{
	int iSize = sizeof(MappedCurrencies);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedCurrencies, iSize, "MappedCurrencies", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_InvRewardRequest[];
#define TYPE_parse_InvRewardRequest InvRewardRequest
//Structparser.exe autogenerated ParseTable for struct MappedItemAssignment
#define TYPE_parse_MappedItemAssignment MappedItemAssignment
ParseTable parse_MappedItemAssignment[] =
{
	{ "MappedItemAssignment", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedItemAssignment), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "hDef",					TOK_REFERENCE(MappedItemAssignment, hDef, 0, "ItemAssignmentDef") },
	{ "DisplayName",			TOK_UNOWNED | TOK_STRING(MappedItemAssignment, pchDisplayName, 0), NULL },
	{ "Icon",					TOK_POOL_STRING | TOK_STRING(MappedItemAssignment, pchIcon, 0), NULL },
	{ "Category",				TOK_AUTOINT(MappedItemAssignment, eCategory, 0), ItemAssignmentCategoryEnum },
	{ "CategoryIcon",			TOK_POOL_STRING | TOK_STRING(MappedItemAssignment, pchCategoryIcon, 0), NULL },
	{ "uAssignmentID",			TOK_AUTOINT(MappedItemAssignment, uAssignmentID, 0), NULL },
	{ "uTimeStarted",			TOK_AUTOINT(MappedItemAssignment, uTimeStarted, 0), NULL , 0 , "JSON_SECS_TO_RFC822 = 1"},
	{ "uFinishDate",			TOK_AUTOINT(MappedItemAssignment, uFinishDate, 0), NULL , 0 , "JSON_SECS_TO_RFC822 = 1"},
	{ "sFinishEarlyCost",		TOK_AUTOINT(MappedItemAssignment, sFinishEarlyCost, -1), NULL },
	{ "SlotIndex",				TOK_AUTOINT(MappedItemAssignment, iSlotIndex, -1), NULL },
	{ "IsLockedSlot",			TOK_BIT, 0, 8, NULL},
	{ "HasCompleteDetails",		TOK_BIT, 0, 8, NULL},
	{ "IsAbortable",			TOK_BIT, 0, 8, NULL},
	{ "Rewards",				TOK_OPTIONALSTRUCT(MappedItemAssignment, pRewards, parse_InvRewardRequest) },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
void FindAutoStructBitField(char *pStruct, int iAllocedSizeInWords, ParseTable *pTPIColumn);
int autoStruct_fixup_MappedItemAssignment()
{
	int iSize = sizeof(MappedItemAssignment);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedItemAssignment, iSize, "MappedItemAssignment", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	{
		int iSizeInWords = (sizeof(MappedItemAssignment) + 7) / 4;
		MappedItemAssignment *pTemp = alloca(iSizeInWords * 4);
		memset(pTemp, 0, iSizeInWords * 4);
		pTemp->bIsLockedSlot = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MappedItemAssignment[12]);
		pTemp->bIsLockedSlot = 0;
		pTemp->bHasCompleteDetails = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MappedItemAssignment[13]);
		pTemp->bHasCompleteDetails = 0;
		pTemp->bIsAbortable = ~0;
		FindAutoStructBitField((char*)pTemp, iSizeInWords, &parse_MappedItemAssignment[14]);
		pTemp->bIsAbortable = 0;
	}
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_MappedItemAssignment[];
#define TYPE_parse_MappedItemAssignment MappedItemAssignment
//Structparser.exe autogenerated ParseTable for struct MappedItemAssignments
#define TYPE_parse_MappedItemAssignments MappedItemAssignments
ParseTable parse_MappedItemAssignments[] =
{
	{ "MappedItemAssignments", 	TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedItemAssignments), 0, NULL, 0, NULL },
	{ "{",						TOK_START, 0 },
	{ "Assignments",			TOK_STRUCT(MappedItemAssignments, ppAssignments, parse_MappedItemAssignment) },
	{ "Complete",				TOK_AUTOINT(MappedItemAssignments, iComplete, 0), NULL },
	{ "Active",					TOK_AUTOINT(MappedItemAssignments, iActive, 0), NULL },
	{ "}",						TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MappedItemAssignments()
{
	int iSize = sizeof(MappedItemAssignments);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedItemAssignments, iSize, "MappedItemAssignments", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
//autogeneratednocheckin
extern ParseTable parse_OwnedContainer[];
#define TYPE_parse_OwnedContainer OwnedContainer
extern ParseTable parse_MappedInventory[];
#define TYPE_parse_MappedInventory MappedInventory
extern ParseTable parse_MappedAttribs[];
#define TYPE_parse_MappedAttribs MappedAttribs
extern ParseTable parse_MappedCurrencies[];
#define TYPE_parse_MappedCurrencies MappedCurrencies
extern ParseTable parse_MappedItemAssignments[];
#define TYPE_parse_MappedItemAssignments MappedItemAssignments
extern ParseTable parse_ItemAssignmentCategoryUIList[];
#define TYPE_parse_ItemAssignmentCategoryUIList ItemAssignmentCategoryUIList
//Structparser.exe autogenerated ParseTable for struct MappedEntity
#define TYPE_parse_MappedEntity MappedEntity
ParseTable parse_MappedEntity[] =
{
	{ "MappedEntity", 				TOK_IGNORE | TOK_PARSETABLE_INFO, sizeof(MappedEntity), 0, NULL, 0, NULL },
	{ "{",							TOK_START, 0 },
	{ "id",							TOK_AUTOINT(MappedEntity, id, 0), NULL },
	{ "Hidden",						TOK_AUTOINT(MappedEntity, bHidden, 0), NULL },
	{ "ViewerIsOwner",				TOK_AUTOINT(MappedEntity, bViewerIsOwner, 0), NULL },
	{ "NeedsFixup",					TOK_AUTOINT(MappedEntity, bNeedsFixup, 0), NULL },
	{ "Name",						TOK_ESTRING | TOK_STRING(MappedEntity, estrName, 0), NULL },
	{ "Title",						TOK_ESTRING | TOK_STRING(MappedEntity, estrTitle, 0), NULL },
	{ "ClassName",					TOK_ESTRING | TOK_STRING(MappedEntity, estrClassName, 0), NULL },
	{ "ClassIcon",					TOK_ESTRING | TOK_STRING(MappedEntity, estrClassIcon, 0), NULL },
	{ "LastMapName",				TOK_ESTRING | TOK_STRING(MappedEntity, estrLastMapName, 0), NULL },
	{ "GenderName",					TOK_ESTRING | TOK_STRING(MappedEntity, estrGenderName, 0), NULL },
	{ "ClassType",					TOK_POOL_STRING | TOK_STRING(MappedEntity, pcClassType, 0), NULL },
	{ "PublicAccountName",			TOK_ESTRING | TOK_STRING(MappedEntity, estrPublicAccountName, 0), NULL },
	{ "SpeciesName",				TOK_ESTRING | TOK_STRING(MappedEntity, estrSpeciesName, 0), NULL },
	{ "History",					TOK_ESTRING | TOK_STRING(MappedEntity, estrHistory, 0), NULL },
	{ "GuildName",					TOK_ESTRING | TOK_STRING(MappedEntity, estrGuildName, 0), NULL },
	{ "LastPlayed",					TOK_ESTRING | TOK_STRING(MappedEntity, estrLastPlayed, 0), NULL },
	{ "Description",				TOK_ESTRING | TOK_STRING(MappedEntity, estrDescription, 0), NULL },
	{ "Level",						TOK_AUTOINT(MappedEntity, iLevel, 0), NULL },
	{ "LevelUi",					TOK_AUTOINT(MappedEntity, iLevelUi, 0), NULL },
	{ "MaxHealth",					TOK_AUTOINT(MappedEntity, iMaxHealth, 0), NULL },
	{ "OwnedContainers",			TOK_STRUCT(MappedEntity, ppOwned, parse_OwnedContainer) },
	{ "Inventory",					TOK_OPTIONALSTRUCT(MappedEntity, pInventory, parse_MappedInventory) },
	{ "Attribs",					TOK_OPTIONALSTRUCT(MappedEntity, pAttribs, parse_MappedAttribs) },
	{ "AttribPrimary",				TOK_POOL_STRING | TOK_STRING(MappedEntity, pchAttribPrimary, 0), NULL },
	{ "AttribSecondary",			TOK_POOL_STRING | TOK_STRING(MappedEntity, pchAttribSecondary, 0), NULL },
	{ "AttribTertiary",				TOK_POOL_STRING | TOK_STRING(MappedEntity, pchAttribTertiary, 0), NULL },
	{ "Currencies",					TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(MappedEntity, pCurrencies, parse_MappedCurrencies) },
	{ "ItemAssignments",			TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(MappedEntity, pItemAssignments, parse_MappedItemAssignments) },
	{ "ItemAssignmentCategories",	TOK_SELF_ONLY | TOK_OPTIONALSTRUCT(MappedEntity, pItemAssignmentCategories, parse_ItemAssignmentCategoryUIList) },
	{ "AuctionSettings",			TOK_ESTRING | TOK_STRING(MappedEntity, pchAuctionSettings, 0), NULL },
	{ "}",							TOK_END, 0 },
	{ "", 0, 0 }
};
int autoStruct_fixup_MappedEntity()
{
	int iSize = sizeof(MappedEntity);
	static char once = 0;
	if (once) return 0;
	once = 1;
	ParserSetTableInfo(parse_MappedEntity, iSize, "MappedEntity", NULL, "NNOGatewayMappedEntity.c", 0 | SETTABLEINFO_ALLOW_CRC_CACHING  );
	return 0;
};
